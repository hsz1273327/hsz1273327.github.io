---
title: "使用Sphinx写项目文档"
date: 2020-11-17
author: "Hsz"
category: recommend
tags:
    - DocumentTool
header-img: "img/home-bg-o.jpg"
update: 2020-11-17
series:
    get_along_well_with_github:
        index: 6
---
# 使用sphinx写项目文档

[Sphinx](https://www.sphinx-doc.org/en/master/)是一个开源的python文档生成器,这里有一个[中文的使用手册](http://zh-sphinx-doc.readthedocs.io/en/latest/),它采用`reStructuredText`作为默认的源文件格式,也可以配置使用`markdown`作为源文件,可以输出为html文件或者pdf文件(需要latex)等多种格式.

由于它自带解析python docstring的功能,因此非常适合用于给python项目做接口文档.通过其他第三方插件的支持,sphinx也可以为javascript,c/c++,golang自动生成接口文档.

本文会结合例子介绍,会按以下顺序演示在不同的场景下使用sphinx写文档

1. 基本设置,使用markdown写文档
2. 多语言支持
3. 借助工具自动生成对应编程语言的api文档
   1. python
   2. javascript
   3. golang
   4. C/C++

## 安装与设置

Sphinx需要python作为运行环境,安装只要`pip install sphinx`就可以.

sphinx项目的基本构建过程是:

1. 使用快速构建工具构建文档项目

2. 修改`conf.py`做全局设置

3. 编写文档源文件

4. 编译文档源文件构造为目标输出格式

### 构建文档项目

Sphinx提供了两个快速构建工具用于构造一个文档项目.

1. `sphinx-quickstart`用于从0开始构造一个文档项目.
2. `sphinx-apidoc`用于在已有python模块的情况下快速构建一个文档项目

介于本文并不是专门针对python项目的,这部分我们介绍第一种快速构建工具.`sphinx-apidoc`则会在[为Python项目创建api文档]部分介绍.

使用`sphinx-quickstart`创建文档项目.会一步一步提示你填写好项目的基本信息,如果懒得进入交互填写,可以用如下命令

```bash
sphinx-quickstart --no-sep -v <项目版本> -r <项目发行版本> -p <项目名> -a <作者名>  -l <使用的语言> [ --ext-todo --ext-mathjax --ext-viewcode [文档源文件所在目录]]
```

使用`sphinx-quickstart`创建文档项目有以下几点需要注意

+ 如果`项目版本`和`项目发行版本`一致,则只有项目版本,否则形式为`<项目版本>rc<项目发行版本>`
+ `--no-sep -v <项目版本> -r 0.0.0 -p <项目发行版本> -a <作者名>  -l <使用的语言>`这几个中只要有一个没填就需要进交互去填写
+ `使用的语言`只支持如下:

    | 缩写       | 语言                 |
    | ---------- | -------------------- |
    | `ar`       | 阿拉伯语             |
    | `bg`       | 保加利亚语           |
    | `bn`       | 孟加拉               |
    | `ca`       | 加泰罗尼亚语         |
    | `cak`      | 喀克其奎语           |
    | `cs`       | 捷克语               |
    | `cy`       | 威尔士语             |
    | `da`       | 丹麦语               |
    | `de`       | 德语                 |
    | `el`       | 希腊语               |
    | `en`       | 英语                 |
    | `eo`       | 世界语               |
    | `es`       | 西班牙语             |
    | `et`       | 爱沙尼亚语           |
    | `eu`       | 巴斯克语             |
    | `fa`       | 伊朗语               |
    | `fi`       | 芬兰语               |
    | `fr`       | 法语                 |
    | `he`       | 希伯来语             |
    | `hi`       | 印地语               |
    | `hi_IN`    | 印度印地语           |
    | `hr`       | 克罗地亚语           |
    | `hu`       | 匈牙利语             |
    | `id`       | 印度尼西亚语         |
    | `it`       | 意大利语             |
    | `ja`       | 日语                 |
    | `ko`       | 韩语                 |
    | `lt`       | 立陶宛语             |
    | `lv`       | 拉脱维亚语           |
    | `mk`       | 马其顿语             |
    | `nb_NO`    | 书面挪威语           |
    | `ne`       | 尼泊尔语             |
    | `nl`       | 荷兰语               |
    | `pl`       | 波兰语               |
    | `pt`       | 葡萄牙语             |
    | `pt_BR`    | 巴西葡萄牙语         |
    | `pt_PT`    | 欧洲葡萄牙语         |
    | `ro`       | 罗马尼亚语           |
    | `ru`       | 俄语                 |
    | `si`       | 僧伽罗语             |
    | `sk`       | 斯洛伐克语           |
    | `sl`       | 斯洛文尼亚语         |
    | `sq`       | 阿尔巴尼亚语         |
    | `sr`       | 塞尔维亚语           |
    | `sr@latin` | 塞尔维亚语(拉丁文)   |
    | `sr_RS`    | 塞尔维亚语(西里尔文) |
    | `sv`       | 瑞典语               |
    | `ta`       | 泰米尔语             |
    | `te`       | 泰卢固语             |
    | `tr`       | 土耳其语             |
    | `uk_UA`    | 乌克兰语             |
    | `ur`       | 乌尔都语             |
    | `vi`       | 越南语               |
    | `zh_CN`    | 简体中文             |
    | `zh_TW`    | 繁体中文             |


+ `文档源文件所在目录`可以缺省,缺省就是在执行目录生成.建议在项目的`document`目录下创建.
+ `--ext-todo --ext-mathjax --ext-viewcode`是推荐的通用插件,建议都安上.
    + `todo` 一个TODO list插件
    + `mathjax` 可以显示latex写成的公式
    + `viewcode` 可以查看到项目的源码

一路按照提示选择,创建好后目录结构大约是这样:

```bash
|-_build # 用于存放编译好的文档结果
|-_static # 用于存放模板的静态资源文件
|-_templates # 用于存放模板文件
|-conf.py # 文档项目的配置项
|-index.rst # 首页源文件
|-Makefile # 非windows平台用于编译文档项目的makefile文件
|-make.bat # windows平台用于编译文档项目的makefile文件
```

### 修改`conf.py`

`conf.py`是sphinx文档项目的配置文件,它就是一个python脚本,使用上面的方式创建出来的`conf.py`大致如下:

```python
project = 'sample'
copyright = '2020, hsz'
author = 'hsz'

# 确定项目版本
version = '0.0.0'
release = '0.0.0'

# 使用的插件
extensions = [
    'sphinx.ext.todo',
    'sphinx.ext.mathjax',
    'sphinx.ext.viewcode',
]

# 指定模板所在文件夹位置
templates_path = ['_templates']

# 文档语言
language = 'en'

# 不进行编译的文件/文件夹
exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']

# 设置不同后缀的文件使用不同解析器(这个需要后加)
source_suffix = {
    '.rst': 'restructuredtext'
}



# 指定编译成html时使用的主题
html_theme = 'alabaster'

# 指定编译成html时使用的静态文件所在位置
html_static_path = ['_static']


# todo插件的设置
todo_include_todos = True
```

我们可以直接在`conf.py`中通过python代码进行设置,设置的基本模式是:

> 如果上面已经有了但需要修改,就直接修改

+ 修改主题
  
    ```python
    html_theme = "alabaster"
    ```

    自带的主题可以在[这里查找](https://www.sphinx-doc.org/en/master/usage/theming.html#builtin-themes).

    个人比较推荐的自带主题是`alabaster`,其设置可以参考下面

    ```python
    html_theme = "sphinx_rtd_theme"
    html_sidebars = {
        '**': [
            'about.html',
            'navigation.html',
            'relations.html',
            'searchbox.html',
            'donate.html',
        ]
    }
    ```

    都不喜欢的话可以去[这里查找第三方主题](https://sphinx-themes.org/),第三方主题需要先安装.

    个人比较推荐的第三方主题是`sphinx_rtd_theme`,其设置为

    ```python
    import sphinx_rtd_theme
    extensions.append('sphinx_rtd_theme')
    html_theme = "sphinx_rtd_theme"
    html_theme_options = {
        'logo_only': True,
        'navigation_depth': 5,
    }
    ```

> 如果是原本支持功能,就直接设置对应的参数,比较常用的设置包括:

+ 设置latex的编译配置:

    ```python
    latex_engine = 'xelatex'
    latex_elements = {
        'fontpkg': r'''
    \setmainfont{DejaVu Serif}
    \setsansfont{DejaVu Sans}
    \setmonofont{DejaVu Sans Mono}
    ''',
        'preamble': r'''
    \usepackage[titles]{tocloft}
    \cftsetpnumwidth {1.25cm}\cftsetrmarg{1.5cm}
    \setlength{\cftchapnumwidth}{0.75cm}
    \setlength{\cftsecindent}{\cftchapnumwidth}
    \setlength{\cftsecnumwidth}{1.25cm}
    ''',
        'fncychap': r'\usepackage[Bjornstrup]{fncychap}',
        'printindex': r'\footnotesize\raggedright\printindex',
    }
    latex_show_urls = 'footnote'
    ```

> 如果是通过插件支持的功能,则需要先在``中添加插件,然后写入插件的配置.比如

+ 配置对markdown的支持(需要先安装依赖`pip install --upgrade recommonmark`)

    ```python
    from recommonmark.transform import AutoStructify
    from recommonmark.parser import CommonMarkParser
    # 使用插件支持markdowm
    # 使用插件支持markdowm
    extensions.append('recommonmark')

    # 针对`.md`为后缀的文件做markdown渲染
    source_suffix[".md"] = 'markdown'

    # 设置markdown渲染器的自定义项

    def setup(app):
        github_doc_root = 'https://localhost:5000'
        app.add_config_value('recommonmark_config', {
            #'url_resolver': lambda url: github_doc_root + url, # 如果不是本地调试,可以将自己项目的url根目录写上
            "enable_auto_toc_tree": True,
            "auto_toc_tree_section": "目录",
            'auto_toc_maxdepth': 2, # 设置toc_tree深度
            "enable_math": True, # 支持```math,注意目前inline_math会有问题因此不建议使用.
            'enable_eval_rst': True, # 支持嵌入rst
        }, True)
    ```

### 使用markdown编写文档

我们的[第一个例子](https://github.com/hsz1273327/hsz1273327.github.io/tree/sphinx-example-markdown)是纯粹使用sphinx渲染markdown.这个例子中我们的入口是`index.md`,它有个目录项会将`page1.md`和`page2.md`引入文件.

### 编译源文档

编译源文档可以有两种方法:

> 使用`make`命令

`make <目标文件类型>`命令可以在`_build`目录下简单快捷地构建文档.最常用的就是`make html`.我们可以看下`make`的源码:

```makefile
# Minimal makefile for Sphinx documentation
#

# You can set these variables from the command line, and also
# from the environment for the first two.
SPHINXOPTS    ?=
SPHINXBUILD   ?= sphinx-build
SOURCEDIR     = .
BUILDDIR      = _build

# Put it first so that "make" without argument is like "make help".
help:
    @$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

.PHONY: help Makefile

# Catch-all target: route all unknown targets to Sphinx using the new
# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
%: Makefile
    @$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

```

可以看出它实际就是执行`sphinx-build`命令,我们如果追求简单可以直接修改其中的参数固化每次的编译行为,比如修改`BUILDDIR`为`../docs`这样方便直接给`Github Page`使用

> 使用`sphinx-build [options] sourcedir builddir [filenames]`来构建.

上面就可以看出`sphinx-build`是`make`的底层,用它可以更灵活的构建.其中`sourcedir`是源文件目录,`builddir`是生成文件目录, `filenames`用于指定要编译的文件,一般不需要写
默认情况下`sphinx-build`只会编译有变化的文件

脚本 `sphinx-build`的可选参数有:

+ `-b` 生成器名字

    生成器,决定了生成文档的类型,是最重要的选项.通用的生成器有:

    + `html` 生成`HTML`文档. 默认的生成器.
    + `dirhtml` 生成`HTML`文档,但是每个文档都有单一的目录,在用浏览器访问时有漂亮的URLs(没有后缀`.html`)
    + `singlehtml` 所有内容生成单一的`HTML`
    + `htmlhelp`,`qthelp`,`devhelp`,`epub` 生成`HTML`文档,建立文档集时包含这些类型之一的额外信息.
    + `latex` 生成`LaTeX`源,可使用指定的latex编译器将其编译成`PDF`文档.默认使用的是`xelatex`
    + `man` 生成UNIX系统的`groff`格式手册.
    + `texinfo` 生成`Texinfo`文件,可以使用`makeinfo`产生`Info`文件.
    + `text` 生成纯文本文件.
    + `gettext` 生成`gettext-style`分类信息(`.pot` 文件).
    + `linkcheck` 检查所有外部链接的可信度.查看`Available builders`，列出了`Sphinx`支持的所有生成器及其可添加的扩展.

+ `-a` 给出时重写全部文档，默认则仅重新生成有新的源文件或源文件被修改的文档.(不适用于所有生成器)

+ `-E` 不使用保存的`environment`(环境，缓存了所有的参考索引),而是完全重建.默认仅读取和解析最近新添加及改动的源文件.

+ `-t <tag>` 定义标签`<tag>`.与`only`指令相关,标签是一个目录集合,仅处理标签目录中的内容.

+ -`d <path>`目前Sphinx生成输出前会读取和解析所有的源文件,解析过的源文件被缓存成"doctree pickles".通常,这些文件被放在生成目录的 `.doctrees`文件夹中;这个选项可以选择不同的缓存目录(`doctrees`可以被所有的生存器共享).

+ `-c <path>` 不使用源目录下的`conf.py`而是使用指定的配置文件.注意在配置文件中提及的路径都是相对配置文件所在目录的相对路径,因此路径必须一致.

+ `-C` 不查找配置文件，仅使用选项`-D`的配置.

+ `-D setting=<value>` 覆盖`conf.py`里的配置值.`value`是一个字符串或字典.例如:`-D latex_elements.docclass=scrartcl`.布尔值使用`0`或 `1`代替.

+ `-A name=<value>` 模板里的`name`变量使用`value`值代替.

+ `-n` 采用`nit-picky`模式.该模式下所有错误都会产生警告信息.

+ `-N` 不产生彩色输出.(在Windows下,彩色输出一直是不可用的)

+ `-q` 不产生标准输出,仅使用标准错误输出输出警告和错误信息.

+ `-Q` 不产生标准输出,也不产生警告信息,仅使用标准错误输出输出错误信息.

+ `<-w file>` 除标准错误输出外,将警告(错误)输出到指定文件.

+ `-W`将警告视为错误.产生第一个警告就停止文档生成活动,`sphinx-build` 在状态`1`退出.

+ `-P` 发生未绑定的异常时运行Python调试器`pdb`.(仅在调试时使用)

## 多语言支持

上面的例子中我们已经使用`language = 'zh_CN'`设定了文档使用的语言.但如果一个项目希望国际化,不可避免的会需要多语言支持,Sphinx自然也有对应的方案.

要支持多语言我们会用到sphinx-intl:

+ `pip install sphinx-intl`.

+ `config.py`中添加设置

```python
locale_dirs = ['locale/']   #
gettext_compact = False     # optional.
```

+ 将文档内容转化为`pot`文件,放入`document/_build/gettext`文件夹下

    ```bash
    sphinx-build -b gettext document document/_build/gettext
    ```

+ 使用`sphinx-intl`工具将`pot`文件都转化成`po`文件用于翻译

    ```bash
    sphinx-intl update -p document/_build/gettext -d document/locale -l 语言1 -l 语言2 ...
    ```

    这一步的`-d document/locale`和上面配置的`locale_dirs`对应

+ 翻译

    上一步以后我们可以在文档源文件文件夹下获得一个`locale`文件夹.其结构如下:

    ```bash
    locale\
          |- en\
               |- index.po
               |- xxx.po
               |-...
          |- fr\
               |- index.po
               |- xxx.po
               |...
          |- ....

    ```

    一种语言会对应一个文件夹,其中的文件和源文件是一一对应的关系.每个`.po`文件类似如下:

    ```po
    # SOME DESCRIPTIVE TITLE.
    # Copyright (C) 2020, hsz
    # This file is distributed under the same license as the sample package.
    # FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
    #
    #, fuzzy
    msgid ""
    msgstr ""
    "Project-Id-Version: sample 0.0.0\n"
    "Report-Msgid-Bugs-To: \n"
    "POT-Creation-Date: 2020-11-20 14:21+0800\n"
    "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
    "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
    "Language-Team: LANGUAGE <LL@li.org>\n"
    "MIME-Version: 1.0\n"
    "Content-Type: text/plain; charset=utf-8\n"
    "Content-Transfer-Encoding: 8bit\n"
    "Generated-By: Babel 2.9.0\n"

    #: ../../index.md:5
    msgid "Page1"
    msgstr ""

    #: ../../index.md:5
    msgid "Page2"
    msgstr ""

    #: ../../index.md:1
    msgid "Welcome to sample's documentation!"
    msgstr ""

    #: ../../index.md:3
    msgid "Example"
    msgstr ""

    #: ../../index.md:5
    msgid "目录"
    msgstr "Index"
    ```

    其中`#`为注释,`msgid`为源文件中的内容,`msgstr`为待翻译内容.这一步的任务就是把`msgstr`都填完.

+ 编译

    还是使用`sphinx-build`,只是需要加上`-D language='<语言>'`并且注意目标文件夹,建议将目标文件夹放在主文件夹下的子文件夹下.

    ```bash
    sphinx-build -D language='fr' -b html document docs/fr
    ```

### 单一静态站的多语言支持

上面就是多语言支持的完整步骤了,不过要注意,不同语言的静态页面本质上都是不相关独立静态网站,要将他们联系起来我们要借助sphinx的扩展能力.

sphinx支持使用jinja2语法做扩展,我们可以在`_template`文件夹下写一个`versions.html`(注意由于css使用的是`sphinx_rtd_theme`提供的.因此这个方法只能在这个主题中使用)

```html
{% if READTHEDOCS or display_lower_left %}
{# Add rst-badge after rst-versions for small badge style. #}
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Read the Docs</span>
    v: {{ current_version }}
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    {% if languages|length >= 1 %}
    <dl>
      <dt>{{ _('Languages') }}</dt>
      {% for slug, url in languages %}
      {% if slug == current_language %} <strong> {% endif %}
        <dd><a href="{{ url }}">{{ slug }}</a></dd>
        {% if slug == current_language %} </strong> {% endif %}
      {% endfor %}
    </dl>
    {% endif %}
  </div>
</div>
{% endif %}
```

这个模板可以看出,我们会用到变量`display_lower_left`,`version`,`current_language`,和`languages`,因此我们需要在`config.py`中配置这4个变量

```python
...

# 多语言支持
try:
    html_context
except:
    html_context = dict()
html_context["current_version"] = version
html_context['display_lower_left'] = True

# 从环境变量`CURRENT_LANGUAGE`获取当前语言,默认为zh_CN
current_language = os.environ.get('CURRENT_LANGUAGE') if os.environ.get('CURRENT_LANGUAGE') else 'zh_CN'
html_context['current_language'] = current_language

if current_language == 'zh_CN':
    # # POPULATE LINKS TO OTHER LANGUAGES
    html_context['languages'] = [('zh_CN', 'index.html')]

    languages = [lang.name for lang in Path(__file__).parent.joinpath("locale").iterdir() if lang.is_dir()]
    for lang in languages:
        html_context['languages'].append((lang, f'{lang}/index.html'))
else:
    # # POPULATE LINKS TO OTHER LANGUAGES
    html_context['languages'] = [('zh_CN', '../index.html')]

    languages = [lang.name for lang in Path(__file__).parent.joinpath("locale").iterdir() if lang.is_dir()]
    for lang in languages:
        html_context['languages'].append((lang, f'../{lang}/index.html'))

```

`html_context`是在使用模板时变量的保存位置,它是一个字典结构,我们把需要设置的值都放入其中即可.需要注意的是`languages`中的元素是一个展示和路径组成的元组,在编译不同语言的静态页面时,路径往往是不同的(主要是主语言和locale中的语言会有不同),为了解决这个问题,我们要在外部借助环境变量`CURRENT_LANGUAGE`在外部告知编译时的程序.因此编译程序为:

+ linux/macos

    ```bash
    export CURRENT_LANGUAGE=fr && sphinx-build -D language='fr' -b html document docs/fr
    ```

+ windows

    ```powershell
    $env:CURRENT_LANGUAGE="fr"; sphinx-build -D language='fr' -b html document docs/fr
    ```

利用这种方式我们还可以扩展出其他用法,比如将历史版本也带上什么的,不过这就要借助`CI/CD`工具了.具体可以参考[这个项目](https://github.com/maltfield/rtd-github-pages).

## 借助工具自动生成对应编程语言的api文档

sphinx在设计之初主要目的就是给python做项目文档,因此内置了插件`sphinx.ext.autodoc`来自动从python项目的源码中获取`docstring`生成api文档.这也是它能流行的主要原因.

在它越来越流行的同时,用户开始希望它可以将这一特性扩展至其他编程语言.这一功能目前并没有官方实现,但比较接近的有两个第三方项目

+ [autoapi](https://github.com/readthedocs/sphinx-autoapi)

    这个项目目前支持对`Python`,`Javascript`,`Go`,`C#`.只是Python的是稳定版,其他都还在alpha版本,虽然有一些bug,但其实也已经很不错了.

    这个项目使用`pip install sphinx-autoapi`安装.

+ [exhale](https://github.com/svenevs/exhale)

    这个项目仅支持`C/C++`.

接下来的部分我们会介绍上面几种编程语言的自动化api编译.

### 自动生成Python项目的API

在安装好`sphinx-autoapi`后,我们只需要




#######################################################################

1. 修改`conf.py`做全局设置

    我们获得了一个`conf.py`,我将它修改成如下:

    ```python
    #coding: utf-8
    import sys
    import os
    # autodoc需要将python模块引入,因此需要将模块所在位置引入path
    sys.path.insert(0, os.path.abspath('..'))

    import recommonmark
    from recommonmark.transform import AutoStructify
    from recommonmark.parser import CommonMarkParser
    # -- General configuration ------------------------------------------------
    extensions = [
        'sphinx.ext.autodoc',
        'sphinx.ext.viewcode',
        'sphinx.ext.todo',
        'sphinx.ext.mathjax',
    ]
    templates_path = ['_templates']  # templates存放位置
    source_parsers = {
        #'.md': CommonMarkParser,
        '.md': CommonMarkParser,
    }
    source_suffix = ['.rst', '.md']  # 可以识别的后缀
    master_doc = 'index'  # 入口文件名
    project = u'testsphinx'  # 项目名
    copyright = u'2016, hsz'  # 版权
    author = u'hsz'  # 作者
    version = u'0.0.1'  # 版本
    release = u'bsd'  # 授权说明
    language = 'zh_CN'  # 语言
    exclude_patterns = ['_build']  # 排除出的文件夹编译
    pygments_style = 'sphinx'  # 代码高亮样式
    # ---html设置------------------------------------------------
    html_theme = 'alabaster'  # 编译为html时用的主题
    html_static_path = ['_static']  # 静态文件夹所在位置
    # Output file base name for HTML help builder.
    htmlhelp_basename = 'testsphinxdoc' # 帮助文档根名字
    # -- latex设置 ---------------------------------------------
    latex_elements = {
        # The paper size ('letterpaper' or 'a4paper').
        #'papersize': 'letterpaper',

        # The font size ('10pt', '11pt' or '12pt').
        #'pointsize': '10pt',

        # Additional stuff for the LaTeX preamble.
        #'preamble': '',

        # Latex figure (float) alignment
        #'figure_align': 'htbp',
    }
    latex_documents = [
        (master_doc, 'testsphinx.tex', u'testsphinx Documentation',
            u'hsz', 'manual'),
    ]
    # -- manual设置---------------------------------------
    man_pages = [
        (master_doc, 'testsphinx', u'testsphinx Documentation',
            [author], 1)
    ]
    # -- Texinfo 设置 -------------------------------------------
    texinfo_documents = [
        (master_doc, 'testsphinx', u'testsphinx Documentation',
            author, 'testsphinx', 'One line description of project.',
            'Miscellaneous'),
    ]
    #---插件-----------------------------------------------------
    #intersphinx_mapping = {'https://docs.python.org/': None}  # intersphinx
    todo_include_todos = True  # 插件todo启用
    url_doc_root = 'xxxxxxxxxxxxxxxxxxxx'
    def setup(app):
        app.add_config_value('recommonmark_config', {
                'url_resolver': lambda url: url_doc_root + url,
                'auto_toc_tree_section': 'Contents',
                }, True)
        app.add_transform(AutoStructify)
    ```

    其中我配置了对`markdown`的支持,这需要安装一个语法分析器`pip install recommonmark`.这个语法分析器对utf-8支持不好,我们需要修改`recommonmark/states.py`其中一段代码

    ```python
    rawtext=str(content),
    text=str(content),
    ```

    改成

    ```python
    rawtext=str(content.encode("utf-8")).decode("utf-8"),
    text=str(content.encode("utf-8")).decode("utf-8"),
    ```

### `sphinx-apidoc`用于读取python项目的`__doc__`来生成api文档

1. *使用`sphinx-apidoc`搭建项目框架*

    ```shell
    sphinx-apidoc [options] -o <outputdir> <packagedir> [pathnames]
    ```

    + `packagedir` 是生成文档的页面的根目录
    + `outputdir` 是生成源文件的输出目录
    + `pathnames` 给出的路径在生成时不会被忽略.

    脚本`sphinx-apidoc`也有一些选项:

    + `-o <outputdir>`
        给出文档页的根目录.

    + `-f`,`--force`
        通常sphinx-apidoc 不会重写任何文件. 使用该项强制重写所有文件.

    + `-n`,`--dry-run`
        采用该选项，将不会产生任何文件.

    + `-s <suffix>`
        生成文件的后缀名，默认为 rst.

    + `-d <maxdepth>`
        目录的最大层次.

    + `-T`,`--no-toc`
        避免生成文件`modules.rst`. 当有选项`--full`时不起作用.

    + `-F`,`--full`
        创建整个`Sphinx`项目, 与`sphinx-quickstart`使用一样的机制. 大多数配置值被设置为默认,可通过下面选项去修改.

    + `-H project`
        设置项目名

    + `-A author`
        设置作者名

    + `-V version`
        设置文档版本

    + `-R release`
        设置文档的发布版本

+ *配置`conf.py`*

    虽说是自动生成,但也还是要做配置的.配置文件中,在`import sys`后面添加

    ```python
    sys.path.insert(0, os.path.abspath('..'))
    ```

+ *在sphinx项目下使用`make html`构建api文档*

    api文档好不好更多的是看你在代码中段注释用的怎么样.这种方式构建的api文档只有api文档而已,如果要做些定制,就需要知道更多的`sphinx`的细节.在后面会有讲解.



3. 编写项目文档

    从这边开始我们试着给一个超简单的项目写一个说明文档,代码`sample.py`:

    ```python
    # coding:utf-8
    u"""牛顿法扩展都n次方根 :math:`\sqrt[k] a` .的表达式为:
    :math:`x_{n+1} = x_n - \\frac {x_n^k-a} {kx_n^{k-1}} = \\frac {k-1}{k} x_n + \\frac {a}{kx_n^{k-1}}`

    """
    def sqrt_nt(n, m, round_=5):
        u"""牛顿法开根号.

        用法: :math:`sqrt\_nt(n,m,round) = \sqrt[m] n`

        Parameters:
            n:<int,float,long> - 被开方的数
            m:<int,float,long>  - 开多少次方
            round:<int> - 精度

        Returns:
            <int,float,long,complex> -开方结果

        Raises:
            TypeError - 参数类型不对时报错
            ValueError - 被开方参数为复数时报错
        """
        if all(map(lambda x: isinstance(x, (int, float, long,)), [n, m])):
            if n < 0:
                raise ValueError(u"必须是整数")
            elif n == 0:
                return 0
            elif n == 1:
                return 1
            else:
                deviation = 0.1**(round_+1)
                seed = n / m
                counter = 0
                max_count = 100000
                now_value = seed
                last_value = 0
                while abs(now_value - last_value) > deviation:
                    if counter > max_count:
                        raise ValueError(u"在{count}次循环内未能得到精度为{round}的解".format(
                            count=max_count, round=round_))
                    counter += 1
                    last_value = now_value
                    now_value = (1 - 1.0 / m) * last_value + \
                        n / (m * last_value**(m - 1))
                return round(now_value, round_)

        else:
            raise TypeError(u"必须是数")
    ```

    我在`__doc__`中插入了`Latex`数学公式,公式的插入方式就是`:math:`+反引号对.

    最终我们写了三个文件:

    + `index.md`:

        ```markdown
        # 欢迎来到Sample的文档

        Sample是一个测试用的模块,它实现了一个牛顿法开根的方法

        内容:

        * [说明](README.md)
        * [API文档](APIdoc.md)

        # 补充引用

        [sample code](../../../sample.py)

        [search](search.html)
        ```

    + `README.md`

        ```markdown
        # 安装

        复制模块到要用的文件位置

        # 使用

        ## 参数

        + n 被开方数

        + m 开方次数

        + round 精度

                from sample import sqrt_nt
                sqrt(2,2)
                sqrt(3,2,5)
        ```

    + `APIdoc.md`

            # Sample API文档

            ## sample 模块

            ```eval_rst
            .. automodule:: sample
                :members:
                :undoc-members:
                :show-inheritance:
            ```

4. 构建文档

    构建文档项目可以有两种方法:

    + 使用`make`命令,`make <目标文件类型>`命令可以在`_build`目录下简单快捷地构建文档.

    + 使用`sphinx-build [options] sourcedir builddir [filenames]`来构建.

        + `sphinx-build`是`make`的底层,用它可以更灵活的构建.
        + `sourcedir`是源文件目录,
        + `builddir`是生成文件目录
        + 一般不需要写`filenames`

        脚本 `sphinx-build`的选项有:

        + `-b` 生成器名字

            生成器,决定了生成文档的类型,是最重要的选项. 通用的生成器有:

            + `html` 生成`HTML`文档. 默认的生成器.
            + `dirhtml` 生成`HTML`文档,但是每个文档都有单一的目录,在用浏览器访问时有漂亮的URLs(没有后缀`.html`)
            + `singlehtml` 所有内容生成单一的`HTML`
            + `htmlhelp`,`qthelp`,`devhelp`,`epub` 生成`HTML`文档,建立文档集时包含这些类型之一的额外信息.
            + `latex` 生成`LaTeX`源,可使用`pdflatex`将其编译成`PDF`文档.
            + `man` 生成UNIX系统的`groff`格式手册.
            + `texinfo` 生成`Texinfo`文件,可以使用`makeinfo`产生`Info`文件.
            + `text` 生成纯文本文件.
            + `gettext` 生成`gettext-style`分类信息(`.pot` 文件).
            + `doctest` 运行文档集内所有测试,如果`doctest`扩展可用.
            + `linkcheck` 检查所有外部链接的可信度.查看`Available builders`，列出了`Sphinx`支持的所有生成器及其可添加的扩展.

        + `-a` 给出时重写全部文档，默认则仅重新生成有新的源文件或源文件被修改的文档.(不适用于所有生成器)

        + `-E` 不使用保存的`environment`(环境，缓存了所有的参考索引),而是完全重建.默认仅读取和解析最近新添加及改动的源文件.

        + `-t <tag>` 定义标签`<tag>`.与`only`指令相关,标签是一个目录集合,仅处理标签目录中的内容.

        + -`d <path>`目前Sphinx生成输出前会读取和解析所有的源文件,解析过的源文件被缓存成"doctree pickles".通常,这些文件被放在生成目录的 `.doctrees`文件夹中;这个选项可以选择不同的缓存目录(`doctrees`可以被所有的生存器共享).

        + `-c <path>` 不使用源目录下的`conf.py`而是使用指定的配置文件.注意在配置文件中提及的路径都是相对配置文件所在目录的相对路径,因此路径必须一致.

        + `-C` 不查找配置文件，仅使用选项`-D`的配置.

        + `-D setting=<value>` 覆盖`conf.py`里的配置值.`value`是一个字符串或字典.例如:`-D latex_elements.docclass=scrartcl`.布尔值使用`0`或 `1`代替.

        + `-A name=<value>` 模板里的`name`变量使用`value`值代替.

        + `-n` 采用`nit-picky`模式.该模式下所有错误都会产生警告信息.

        + `-N` 不产生彩色输出.(在Windows下,彩色输出一直是不可用的)

        + `-q` 不产生标准输出,仅使用标准错误输出输出警告和错误信息.

        + `-Q` 不产生标准输出,也不产生警告信息,仅使用标准错误输出输出错误信息.

        + `<-w file>` 除标准错误输出外,将警告(错误)输出到指定文件.

        + `-W`将警告视为错误.产生第一个警告就停止文档生成活动,`sphinx-build` 在状态`1`退出.

        + `-P` 发生未绑定的异常时运行Python调试器`pdb`.(仅在调试时使用)

    源目录与目标目录后面,可以给出一个到多个文件名.`Sphinx`会尝试仅生成这些文件(及其依赖文件).


## 为Python项目创建api文档

 + `doctest` 运行文档集内所有测试,如果`doctest`扩展可用.

## 为Javascript项目创建api文旦

## 为Golang项目创建api文档

## 为C/C++项目创建api文档




sphinx项目的基本构建过程是:

1. 使用快速构建工具搭建项目框架

2. 修改`conf.py`做全局设置

3. (可选)编写文档内容,本文将会讲如何用Markdown来写内容

4. 构建文档

    构建文档项目可以有两种方法:

    + 使用`make`命令,`make <目标文件类型>`命令可以在`_build`目录下简单快捷地构建文档.

    + 使用`sphinx-build [options] sourcedir builddir [filenames]`来构建.

        + `sphinx-build`是`make`的底层,用它可以更灵活的构建.
        + `sourcedir`是源文件目录,
        + `builddir`是生成文件目录
        + 一般不需要写`filenames`

        脚本 `sphinx-build`的选项有:

        + `-b` 生成器名字

            生成器,决定了生成文档的类型,是最重要的选项. 通用的生成器有:

            + `html` 生成`HTML`文档. 默认的生成器.
            + `dirhtml` 生成`HTML`文档,但是每个文档都有单一的目录,在用浏览器访问时有漂亮的URLs(没有后缀`.html`)
            + `singlehtml` 所有内容生成单一的`HTML`
            + `htmlhelp`,`qthelp`,`devhelp`,`epub` 生成`HTML`文档,建立文档集时包含这些类型之一的额外信息.
            + `latex` 生成`LaTeX`源,可使用`pdflatex`将其编译成`PDF`文档.
            + `man` 生成UNIX系统的`groff`格式手册.
            + `texinfo` 生成`Texinfo`文件,可以使用`makeinfo`产生`Info`文件.
            + `text` 生成纯文本文件.
            + `gettext` 生成`gettext-style`分类信息(`.pot` 文件).
            + `doctest` 运行文档集内所有测试,如果`doctest`扩展可用.
            + `linkcheck` 检查所有外部链接的可信度.查看`Available builders`，列出了`Sphinx`支持的所有生成器及其可添加的扩展.

        + `-a` 给出时重写全部文档，默认则仅重新生成有新的源文件或源文件被修改的文档.(不适用于所有生成器)

        + `-E` 不使用保存的`environment`(环境，缓存了所有的参考索引),而是完全重建.默认仅读取和解析最近新添加及改动的源文件.

        + `-t <tag>` 定义标签`<tag>`.与`only`指令相关,标签是一个目录集合,仅处理标签目录中的内容.

        + -`d <path>`目前Sphinx生成输出前会读取和解析所有的源文件,解析过的源文件被缓存成"doctree pickles".通常,这些文件被放在生成目录的 `.doctrees`文件夹中;这个选项可以选择不同的缓存目录(`doctrees`可以被所有的生存器共享).

        + `-c <path>` 不使用源目录下的`conf.py`而是使用指定的配置文件.注意在配置文件中提及的路径都是相对配置文件所在目录的相对路径,因此路径必须一致.

        + `-C` 不查找配置文件，仅使用选项`-D`的配置.

        + `-D setting=<value>` 覆盖`conf.py`里的配置值.`value`是一个字符串或字典.例如:`-D latex_elements.docclass=scrartcl`.布尔值使用`0`或 `1`代替.

        + `-A name=<value>` 模板里的`name`变量使用`value`值代替.

        + `-n` 采用`nit-picky`模式.该模式下所有错误都会产生警告信息.

        + `-N` 不产生彩色输出.(在Windows下,彩色输出一直是不可用的)

        + `-q` 不产生标准输出,仅使用标准错误输出输出警告和错误信息.

        + `-Q` 不产生标准输出,也不产生警告信息,仅使用标准错误输出输出错误信息.

        + `<-w file>` 除标准错误输出外,将警告(错误)输出到指定文件.

        + `-W`将警告视为错误.产生第一个警告就停止文档生成活动,`sphinx-build` 在状态`1`退出.

        + `-P` 发生未绑定的异常时运行Python调试器`pdb`.(仅在调试时使用)

    源目录与目标目录后面,可以给出一个到多个文件名.`Sphinx`会尝试仅生成这些文件(及其依赖文件).

## 项目快速构建工具

sphinx提供了两个快速构建工具

### `sphinx-apidoc`用于读取python项目的`__doc__`来生成api文档

1. *使用`sphinx-apidoc`搭建项目框架*

    ```shell
    sphinx-apidoc [options] -o <outputdir> <packagedir> [pathnames]
    ```

    + `packagedir` 是生成文档的页面的根目录
    + `outputdir` 是生成源文件的输出目录
    + `pathnames` 给出的路径在生成时不会被忽略.

    脚本`sphinx-apidoc`也有一些选项:

    + `-o <outputdir>`
        给出文档页的根目录.

    + `-f`,`--force`
        通常sphinx-apidoc 不会重写任何文件. 使用该项强制重写所有文件.

    + `-n`,`--dry-run`
        采用该选项，将不会产生任何文件.

    + `-s <suffix>`
        生成文件的后缀名，默认为 rst.

    + `-d <maxdepth>`
        目录的最大层次.

    + `-T`,`--no-toc`
        避免生成文件`modules.rst`. 当有选项`--full`时不起作用.

    + `-F`,`--full`
        创建整个`Sphinx`项目, 与`sphinx-quickstart`使用一样的机制. 大多数配置值被设置为默认,可通过下面选项去修改.

    + `-H project`
        设置项目名

    + `-A author`
        设置作者名

    + `-V version`
        设置文档版本

    + `-R release`
        设置文档的发布版本

+ *配置`conf.py`*

    虽说是自动生成,但也还是要做配置的.配置文件中,在`import sys`后面添加

    ```python
    sys.path.insert(0, os.path.abspath('..'))
    ```

+ *在sphinx项目下使用`make html`构建api文档*

    api文档好不好更多的是看你在代码中段注释用的怎么样.这种方式构建的api文档只有api文档而已,如果要做些定制,就需要知道更多的`sphinx`的细节.在后面会有讲解.

### sphinx-quickstart sphinx项目快速构建

这个脚本只是起到一个快速构建项目目录结构和基础配置的作用.相较于前面的`sphinx-apidoc`,它构建的项目更加一般化也更加适合定制.

1. 使用`sphinx-quickstart`创建项目目录

    一路按照提示选择,创建好后目录结构大约是这样:

    ```bash
    |-_build
    |-_static
    |-_templates
    |-conf.py
    |-index.rst
    |-Makefile
    ```

    其中`conf.py`前面已经有过接触,就是设置文件,`index.rst`是主页`index.html`的源文件,`Makefile`都懂得,就是make命令的设置文件

    我们还选择了几个插件:

    + `autodoc` 用来自动生成python文档
    + `intersphinx` 将外链并入项目
    + `todo` 一个TODO list插件
    + `mathjax` 可以显示latex写成的公式
    + `viewcode` 可以查看到python项目的源码

2. 修改`conf.py`做全局设置

    我们获得了一个`conf.py`,我将它修改成如下:

    ```python
    #coding: utf-8
    import sys
    import os
    # autodoc需要将python模块引入,因此需要将模块所在位置引入path
    sys.path.insert(0, os.path.abspath('..'))

    import recommonmark
    from recommonmark.transform import AutoStructify
    from recommonmark.parser import CommonMarkParser
    # -- General configuration ------------------------------------------------
    extensions = [
        'sphinx.ext.autodoc',
        'sphinx.ext.viewcode',
        'sphinx.ext.todo',
        'sphinx.ext.mathjax',
    ]
    templates_path = ['_templates']  # templates存放位置
    source_parsers = {
        #'.md': CommonMarkParser,
        '.md': CommonMarkParser,
    }
    source_suffix = ['.rst', '.md']  # 可以识别的后缀
    master_doc = 'index'  # 入口文件名
    project = u'testsphinx'  # 项目名
    copyright = u'2016, hsz'  # 版权
    author = u'hsz'  # 作者
    version = u'0.0.1'  # 版本
    release = u'bsd'  # 授权说明
    language = 'zh_CN'  # 语言
    exclude_patterns = ['_build']  # 排除出的文件夹编译
    pygments_style = 'sphinx'  # 代码高亮样式
    # ---html设置------------------------------------------------
    html_theme = 'alabaster'  # 编译为html时用的主题
    html_static_path = ['_static']  # 静态文件夹所在位置
    # Output file base name for HTML help builder.
    htmlhelp_basename = 'testsphinxdoc' # 帮助文档根名字
    # -- latex设置 ---------------------------------------------
    latex_elements = {
        # The paper size ('letterpaper' or 'a4paper').
        #'papersize': 'letterpaper',

        # The font size ('10pt', '11pt' or '12pt').
        #'pointsize': '10pt',

        # Additional stuff for the LaTeX preamble.
        #'preamble': '',

        # Latex figure (float) alignment
        #'figure_align': 'htbp',
    }
    latex_documents = [
        (master_doc, 'testsphinx.tex', u'testsphinx Documentation',
            u'hsz', 'manual'),
    ]
    # -- manual设置---------------------------------------
    man_pages = [
        (master_doc, 'testsphinx', u'testsphinx Documentation',
            [author], 1)
    ]
    # -- Texinfo 设置 -------------------------------------------
    texinfo_documents = [
        (master_doc, 'testsphinx', u'testsphinx Documentation',
            author, 'testsphinx', 'One line description of project.',
            'Miscellaneous'),
    ]
    #---插件-----------------------------------------------------
    #intersphinx_mapping = {'https://docs.python.org/': None}  # intersphinx
    todo_include_todos = True  # 插件todo启用
    url_doc_root = 'xxxxxxxxxxxxxxxxxxxx'
    def setup(app):
        app.add_config_value('recommonmark_config', {
                'url_resolver': lambda url: url_doc_root + url,
                'auto_toc_tree_section': 'Contents',
                }, True)
        app.add_transform(AutoStructify)
    ```

    其中我配置了对`markdown`的支持,这需要安装一个语法分析器`pip install recommonmark`.这个语法分析器对utf-8支持不好,我们需要修改`recommonmark/states.py`其中一段代码

    ```python
    rawtext=str(content),
    text=str(content),
    ```

    改成

    ```python
    rawtext=str(content.encode("utf-8")).decode("utf-8"),
    text=str(content.encode("utf-8")).decode("utf-8"),
    ```

3. 编写项目文档

    从这边开始我们试着给一个超简单的项目写一个说明文档,代码`sample.py`:

    ```python
    # coding:utf-8
    u"""牛顿法扩展都n次方根 :math:`\sqrt[k] a` .的表达式为:
    :math:`x_{n+1} = x_n - \\frac {x_n^k-a} {kx_n^{k-1}} = \\frac {k-1}{k} x_n + \\frac {a}{kx_n^{k-1}}`

    """
    def sqrt_nt(n, m, round_=5):
        u"""牛顿法开根号.

        用法: :math:`sqrt\_nt(n,m,round) = \sqrt[m] n`

        Parameters:
            n:<int,float,long> - 被开方的数
            m:<int,float,long>  - 开多少次方
            round:<int> - 精度

        Returns:
            <int,float,long,complex> -开方结果

        Raises:
            TypeError - 参数类型不对时报错
            ValueError - 被开方参数为复数时报错
        """
        if all(map(lambda x: isinstance(x, (int, float, long,)), [n, m])):
            if n < 0:
                raise ValueError(u"必须是整数")
            elif n == 0:
                return 0
            elif n == 1:
                return 1
            else:
                deviation = 0.1**(round_+1)
                seed = n / m
                counter = 0
                max_count = 100000
                now_value = seed
                last_value = 0
                while abs(now_value - last_value) > deviation:
                    if counter > max_count:
                        raise ValueError(u"在{count}次循环内未能得到精度为{round}的解".format(
                            count=max_count, round=round_))
                    counter += 1
                    last_value = now_value
                    now_value = (1 - 1.0 / m) * last_value + \
                        n / (m * last_value**(m - 1))
                return round(now_value, round_)

        else:
            raise TypeError(u"必须是数")
    ```

    我在`__doc__`中插入了`Latex`数学公式,公式的插入方式就是`:math:`+反引号对.

    最终我们写了三个文件:

    + `index.md`:

        ```markdown
        # 欢迎来到Sample的文档

        Sample是一个测试用的模块,它实现了一个牛顿法开根的方法

        内容:

        * [说明](README.md)
        * [API文档](APIdoc.md)

        # 补充引用

        [sample code](../../../sample.py)

        [search](search.html)
        ```

    + `README.md`

        ```markdown
        # 安装

        复制模块到要用的文件位置

        # 使用

        ## 参数

        + n 被开方数

        + m 开方次数

        + round 精度

                from sample import sqrt_nt
                sqrt(2,2)
                sqrt(3,2,5)
        ```

    + `APIdoc.md`

            # Sample API文档

            ## sample 模块

            ```eval_rst
            .. automodule:: sample
                :members:
                :undoc-members:
                :show-inheritance:
            ```

4.构建文档
我们修改makefile中

```shell
.PHONY: html
html:
html:
$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
if [ -d ../docs ];then rm -r ../docs; fi
cp -r $(BUILDDIR)/html ../docs
touch .nojekyll
mv .nojekyll ../docs
@echo
@echo "Build finished. The HTML pages are in $(BUILDDIR)/html"
```

添加把html结果copy出来到docs的命令,这样方便给`githubpage`用
运行`make html`即可

## 使用插件

sphinx有很强的扩展性,他的插件可以在pip里搜`sphinxcontrib`得到,非常多每个用法也会不相同.

使用插件必须要将插件放入`conf.py`的`extensions`变量中
我们在前面已经看到怎么用`autodoc`了,这边继续讲几个比较有价值的

+ `todo` 

    一个todolist插件,`conf.py`中需要额外设置一个参数`todo_include_todos = True`和`todo_link_only=True`
    有两个rst标识:

    + 定义一个todo

            ```eval_rst
            .. todo::

                A

                B

                C

            ```

    + 收集所有项目下的todo

            ```eval_rst
            .. todolist::
            ```

+ `sphinxcontrib-autojs`

    这个插件就是js版本的doctest+autodoc,不过有个小bug,237行需要替换为

    ```python
    self.source = ("".join(f.readlines())).decode("utf-8")
    ```

    加上`decode("utf-8")`才能解析非英文字符

    之后只要在api文档中使用

        ```eval_rst
        .. autojs:: <module path>
            :members: <member name>
        ```

就可以了.它还支持`jsdoctest`.

+ sphinxcontrib-httpdomain

    这个插件是用来写网络RESTapi的,它的配置项有:

    + http_headers_ignore_prefixes 严格模式下屏蔽的http头前缀

        `http_headers_ignore_prefixes = ['X-']`

    + http_index_ignore_prefixes 屏蔽的目录前缀

        `http_index_ignore_prefixes = ['/internal', '/_proxy']`

    + http_index_shortname 目录短名

        `http_index_shortname = 'api'`

    + http_index_localname 目录全名

        `http_index_localname = "My Project HTTP API"`

    + http_strict_mode 严格模式

        `http_strict_mode = True`

    它的用法比较复杂,可以看<https://pythonhosted.org/sphinxcontrib-httpdomain/>,

    本文的例子可以在<https://github.com/hsz1273327/sphinx_markdown_example>看到,
    例子的效果可以在<http://blog.hszofficial.site/sphinx_markdown_example/>看到

+ sphinxcontrib-napoleon

    这个插件可以支持google和numpy风格的api注释

本文的例子可以在[我的github](https://github.com/hsz1273327/sphinx_markdown_example)上看到

## 补充

### **recommonmark对sphinx的markdown扩展支持**

+ 写目录
    我们可以在平时markdown引用链接语法的基础上在前面加上`*`引入下一级文件

    ```markdown
    * [说明](README.md)
    * [API文档](APIdoc.md)
    ```

+ 项目内链引用
    项目内链引用可以直接像一般的url链接一样使用

    ```markdown
    [search](search.html)
    ```

+ url解析
    [sample code](../../../sample.py)
    不过需要在`conf.py`中先把url设定好,通过这种方式可以方便的将静态文件作为下载放在页面中

+ latex公式的解析需要在公式两边加上反引号才能被解析

+ 嵌入 reStructuredText,
    可以使用类似

        ```eval_rst
        .. autoclass:: recommonmark.transform.AutoStructify
            :show-inheritance:
        ```

    的代码嵌入reStructuredText格式的内容

+ 目前不支持表格

### 使用sphinx嫁接doxygen

[doxygen](http://www.doxygen.nl/)是一套多语言的注释文档转接口文档工具,常用在C语言,java等语言上,其作用基本和pydoc一样,只是针对的语言不同.
如果是C语言的项目,或者项目中使用了C语言,那么就会用到它.

sphinx可以通过插件[breathe](https://breathe.readthedocs.io/en/latest/index.html)将doxygen生成的xml文件导入生成的网站

其步骤为:

+ (单独项目的话)使用`sphinx-quickstart`创建sphinx项目

+ 配置`conf.py`,以支持breathe扩展.前提是这一扩展已经安装.

    加入扩展:

    ```python
    extensions = ['breathe']
    ```

+ 在`conf.py`中配置`breathe`:

    ```python
    breathe_projects = { "myproject": "./my_xml" }
    breathe_default_project = "myproject"
    breathe_domain_by_extension = {"h" : "c"}
    ```

+ 在需要的`.rst`文件中加入以下代码引入接口

    按breathe扩展语法编写`rst`文件,比如:

    ```rst
    My API
    ==========

    sp.h
    ----

    .. doxygenfile:: sp.h

    ```

+ 运行 make html 生成html即可.

    在这些步骤中，需要先调用doxygen生成xml，再调用sphinx-build(make html时自动调用)生成最终文档，如果想一步完成，可以在Makefile中加入doxygen调用:

    ```make
    html:
        doxygen Doxyfile
        $(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
        @echo
        @echo "Build finished. The HTML pages are in $(BUILDDIR)/html."
    ```