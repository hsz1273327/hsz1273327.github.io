---
title: "使用Git管理你的代码"
date: 2020-10-31
author: "Hsz"
category: recommend
tags:
    - Git
    - DevOps
    - Git
header-img: "img/home-bg-o.jpg"
update: 2020-11-06
series:
    get_along_well_with_github:
        index: 3
---
# 使用Git管理你的代码

[Git](https://git-scm.com/)是当前最流行的一个开源的分布式版本控制系统,用于敏捷高效地处理任何或小或大的项目.

它是[Linus Torvalds](https://baike.baidu.com/item/%E6%9E%97%E7%BA%B3%E6%96%AF%C2%B7%E6%9C%AC%E7%BA%B3%E7%AC%AC%E5%85%8B%E7%89%B9%C2%B7%E6%89%98%E7%93%A6%E5%85%B9/1034429?fromtitle=Linus%20Torvalds&fromid=9336769&fr=aladdin)为了帮助管理[Linux](https://baike.baidu.com/item/Linux)内核开发而开发的一个开放源码的版本控制软件.

Git最大的特点是分布式.它与以往集中式的版本控制工具最大的不同就是Git的仓库是相互独立的,每个人电脑中都有完整的版本库,所以某人的机器挂了并不影响其它人.这一特性天生对开源软件亲和.

## Git的工作流程

![Git的工作流程][1]

git版本控制系统由工作区,缓存区,版本库组成.它跟踪的是文件的修改而不是全部文件.也就是说它的版本控制靠的是记录变化.因此相比较起管理二进制文件,git更擅长管理代码等文本文件.

## 基本的版本控制

Git是分布式代码仓库,但如果只是本地使用也完全可以用于项目的版本控制.

但无论怎样你都需要先在本地创建一个代码仓库.

### 创建一个git的项目仓库

```bash
git init
```

创建本地仓库后项目根目录下会生成一个`.git`的文件夹,其中`config`文件会记录仓库的一些基本信息.项目会有一个`HEAD`文件用于记录当前的状态.

这个`HEAD`会指向一个分支,一般是`master`分支,分支这个概念我们会在下一单元介绍.

### 提交缓存

```bash
git add <path>
```

创建完成后就是写要管理的项目.我们需要向Git提交缓存变更才能让它记住.只有缓存了的代码才能被管理.我们可以使用`add`子命令将指定路径下的文件/文件夹的修改提交到缓存.为了方便,比较方便的方式是`git add .`

一般情况下我们会在确定没问题的情况下做`add`操作,但如果要取消缓存也不是没有办法可以使用如下命令

```bash
git reset HEAD <file>...
```

这条命令会将当前的缓存区中指定的文件缓存删除.

提交缓存的最佳实践是每次只在提交变更前提交缓存,这样就可以直接使用变更来管理版本.

### 提交变更

```bash
git commit -m <message>
```

当多个缓存定型后我们可以提交一版修改到git,这步会生成了当前项目的一个快照,这个快照用一串字符串唯一标识(`commitID`),并将项目当前的`HEAD`指向这个提交的`commitID`.并将缓存区清空.

每次的提交都会包含如下信息:

+ `commitID`唯一标识
+ `Author`如果有设置的话
+ `Date`提交的日期
+ message 提交时附带的信息
+ 文件差异信息

> 查看提交历史变更

这个信息只要不人工干预就不会被修改删除.依据这个我们可以得到一个由提交串起来的历史提交时间序列.如何查看提交历史呢?

```bash
git log
```

如果添加flag`-p -{n}`就可以查看每次提交所引入的差异,后面的`-{n}`是展示多少条

另一种方式是使用flag`--stat`,它可以看到每次提交的变化统计信息.其他还有几个flag可以用于设置展示形式这里就不详细介绍了,如果感兴趣可以看[这篇](https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2).

> 回退到指定提交

由于每次的快照都会保存且有唯一标识,因此在本地我们可以随时回退到之前的某一次提交上.这就实现了版本控制.

+ `reset`(不推荐)

    第一种方式是回退操作

    ```bash
    git reset --hard HEAD^ 回退到上个版本
    git reset --hard HEAD~3 回退到前3次提交之前,以此类推回退到n次提交之前
    git reset --hard <commitID> 退到/进到指定commit
    ```

    ![reset][4]
    注意回退会修改提交历史树,也就是说回退操作是无法撤销的.

    如果我们希望保留这个历史或者实际上我们只是要撤销某词提交的内容,那么可以使用

+ `revert`

    `revert`准确说并不是回退,而是获取撤销某次提交的结果和当前的状态做合并,并生成一次新的提交.因此它并不会改变提交历史.

    ```bash
    git revert HEAD 撤销当前HEAD指定的提交的修改
    git revert <commitID> 撤销个指定commit的修改
    ```

    ![revert][5]

    `git revert`由于实际上是合并操作,所以可能会造成冲突.如果有冲突就和下面的`merge`一样解决即可

## 使用分支隔离代码

我们可以通过迁出分支来实现代码隔离,比如我们希望功能a和功能b同步开发,同时又担心开发过程中相互影响干扰,那么就可以迁出两个分支`a`和`b`.迁出的分支会指向迁出之前`commitID`.之后这个分支就时基于这次提交的修改了.

### 创建分支

```bash
git branch <分支名>
```

迁出分支会在当前分支下创建一个新的分支指向当前的`commitID`

这操作我们也可以使用`git checkout -b <分支名>`它会在创建新分支之外同时将`HEAD`指向这个新分支.

![创建分支][2]

实际上仓库创建起来后就会默认创建一个`master`分支,无论后面迁出什么分支都可以认为根源上都是来自`master`分支,由于`Head`是指向分支再由分支保存最近的`commitID`的,所以在一个项目中可以每个分支保留自己的最终状态而不相互影响.

> 查看分支列表

我们可以使用

```bash
git branch
```

来查看当前所在分支和当前仓库中有哪些分支

> 切换分支

要在这些分支间切换可以使用

```bash
git checkout <分支名>
```

> 删除分支(不推荐)

当然我们可以删除一些已经无用的分支

```bash
git branch -d <分支名>
```

### 合并分支

每次创建一个分支有个专用的说法叫`项目分叉`,这也就是说项目会在每次创建新分支时出现新的走向.当新的走向需要回归主干时就需要合并分支操作

```bash
git merge <目标分支名>
```

这个合并操作的目的是将目标分支合流到当前分支.因此实际上涉及到的提交点有3个:

1. 当前分支的最近提交
2. 目标分支的最近提交
3. 两个分支的分叉点

![分支合并][3]

合并分支的基本逻辑是将这3者的进行对比

+ 如果没有冲突则直接合并变更生成一次提交,这次提交称作`合并提交`,同时你的当前工作区就成了合并后的样子.
+ 如果有冲突则需要先在工作区解决冲突,之后使用`git commit`手动提交.

    `git merge`命令执行后要合并的分支中文件都会被放入共工作区,同时会标注冲突源,我们只需要将所有冲突源解决就算是解决了冲突.
    有哪些冲突可以通过使用`git status`查看,其中有冲突的文件会被标识为`unmerged`.文件中有冲突的部分进行标注(冲突文件中使用`<<<<<<<`,`=======`和`>>>>>>>`标识冲突来源).现代的编程辅助工具比如vscode,github desktop等都会有明确提示帮助你解决冲突.

### 取消合并分支

取消合并分支本质上也是回退提交,因此和上面一样也是`reset`和`revert`两种方式.我们以下面的分支结构举例

![resetmergebefore][6]

+ `reset`方式(不推荐)

    ```bash
    git reset --hard HEAD~
    ```

    ![reset方式撤销合并][7]

+ `revert`方式

    由于撤销的分支合并,因此会带来一些麻烦点,下面是如何解决这些麻烦点

    1. 撤销合并

        ```bash
        git revert -m 1 HEAD
        ```

        `-m 1` 标记指出"mainline"需要被保留下来的父结点

        ![revert方式撤销合并][8]

    2. 撤销`撤销合并`以便再次从分支中合并

        事实上这样撤销合并后如果我们的`topic`分支修改了一版提交`C7`后想再合并进`master`会提示`Already up-to-date.`.
        如果要让`C7`可以真的合并进`master`我们需要额外做一次撤销操作来撤销刚才的撤销合并.

        ```bash
        git revert <^M的id>
        ```

        ![revert方式撤销撤销合并以便再次合并][9]

### 分支变基(不推荐)

分支合并还有一种方式是变基,不要想歪了....它的作用是将指定分支上的的所有修改都移至另一分支上,就好像"重新播放"一样.以下面的分支结构为例

![变基前][10]

我们在`experiment`分支上执行`git rebase master`.它的原理是首先找到这两个分支(即当前分支`experiment`,变基操作的目标基底分支`master`)的最近共同祖先`C2`,然后对比当前分支相对于该祖先的历次提交,提取相应的修改并存为临时文件,然后将当前分支指向目标基底`C3`, 最后以此将之前另存为临时文件的修改依序应用.这样最终我们所在的`experiment`分支就跑到了`master`分支的前面,而之前在`experiment`的提交就都删除了

![变基后][11]

如果要将`experiment`分支合回`master`,再切回master执行`git merge experiment`就行了.

### 使用分支的最佳实践

> 将分支分类处理

通常我们会将分支分为两种:

1. 长期有效的分支
    他们一般会有固定的作用,并且更进一步的可以和[持续集成](https://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/6250744?fr=aladdin)[持续交付](https://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/9803571?fr=aladdin)有关.比如通常`master`分支要求是长期存在,并且要一直是最近的稳定可执行版本,`dev`分支一般会要求是最近的可执行开发版本等等,这些定义一般根据不同的工作流模型会有不同的分工.

2. 短期特性分支

    这种分支只会在有特定需求时出现,而且必须尽快合并回长期有效分支.一般来说这类分支的作用无外乎几种:
    1. 紧急修复
    2. 增加小特性
    3. 小范围的代码优化

    这类短期特性分支一定要尽快合并进长期有效分支.

> 使用`merge`而不是`rebase`合并分支

我们一般不做变基操作,,变基操作会修改提交记录,虽然可以让你的提交历史树看起来更美观些但不利于历史追踪查询问题和回退.

> 使用`revert`而不是`reset`方式来回退合并提交.

理由和上面一样,我们应该尽量的保证提交历史树的真实性和完整性.

## 使用标签固定版本

如果你隔离代码的目的不是分出一枝继续开发而是单纯的留档,那么分支并不是最优雅的解决方案.标签更合适.

可以简单理解标签是不能修改的分支.管标签操作的命令是`git tag`.

+ 查看列表使用`git tag -l`
+ 创建使用`git tag -a <tag名> -m <message>`,这回将当前的`HEAD`指向的提交打上标签.
    + 如果使用轻量标签可以直接`git tag <tag名>`,注意轻量标签不会有这个操作的元信息.
    + 如果想将历史上的某一次提交打标签可以使用`git -a <tag名> -m <message> <commitID>`
+ 删除使用`git tag -d <tag名>`

### 从标签开始"修改"代码

我们可以使用`git checkout <tag名>`来迁出标签指定的提交.但是注意**标签迁出的代码修改后提交是无效的**.
因此如果要进行修改需要先基于标签创建一个分支(`git checkout -b <分支名>`),然后在分支中修改代码.

## 远程仓库同步

Git的作用当然不是只在本地做做版本管理.它毕竟是**分布式版本控制系统**,是为协作而生的.如何与远程仓库协同才是它最主要解决的问题.

### 裸仓库

通常远程仓库也不是全部都地位相同的,像上面介绍的都是常规仓库,它会有工作区,缓存区,版本库.
而另一种类型的仓库被称作裸仓库,它没有工作区,即你不能直接在这样的仓库里进行正常的git命令操作.这种仓库只能接收和修改历史提交树.

裸仓库的作用就是作为众多分布式仓库的中心仓库.它的作用就是让连接它的人可以共享代码.

> 创建一个裸仓库

```bash
git init --bare
```

### 账户

### 远程仓库管理

### 同步数据


## 常见的工作流模板

### 主干分支策略

### githubflow

### gitflow

## 可视化工具Github Desktop

广为流行的版本控制工具git几乎已经成为行业标准,但其完全命令行操作的特点也确实难到了不少人.github公司开发的githubDesktop工具很好的解决了这个问题.目前该工具已经跨越全部桌面环境,去[官网下载](https://desktop.github.com/)对应版本按提示安装即可.

git命令其实也不复杂,但是作为工具我觉得直观可见是很好的特性,我想这也是github流行的原因吧.所以命令行党请退散~

进入正片

我们先来了解下他的各个部分按钮的作用

![按钮作用][1]

### 项目

点击下左上角的`+`号后会看到这样的:

![创建项目][2]

根据你的需求选择是怎样的创建方式

创建完了之后就是描述和确定版本了,如果需要的话也可以上传去github

## Ref

+ [Pro Git](https://git-scm.com/book/zh/v2)


[1]: {{site.url}}/img/in-post/git/gitworkprocess.webp
[2]: {{site.url}}/img/in-post/git/head-to-testing.png
[3]: {{site.url}}/img/in-post/git/basic-merging-1.png
[4]: {{site.url}}/img/in-post/git/reset.png
[5]: {{site.url}}/img/in-post/git/revert.png
[6]: {{site.url}}/img/in-post/git/resetmergebefore.png
[7]: {{site.url}}/img/in-post/git/undomerge-reset.png
[8]: {{site.url}}/img/in-post/git/undomerge-revert.png
[9]: {{site.url}}/img/in-post/git/undomerge-revert3.png
[10]: {{site.url}}/img/in-post/git/basic-rebase-1.png
[11]: {{site.url}}/img/in-post/git/basic-rebase-3.png

[20]: {{site.url}}/img/in-post/git/gitdesktop_global.png
[21]: {{site.url}}/img/in-post/git/githubdesktop_project.png
