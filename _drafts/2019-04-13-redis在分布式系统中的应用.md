---
layout: post
title: "redis在分布式系统中的应用"
date: 2019-04-13
author: "Hsz"
category: experiment
tags:
    - Architecture
    - Middleware
header-img: "img/home-bg-o.jpg"
update: 2020-12-31
---
# redis在分布式系统中的应用

redis作为一个key-value内存数据库,因为其附带有性能优越的多种数据结构,在应用上带来了很多附加功能呢.在分布式系统中redis常作为一些特殊的中间件存在而非单纯的内存数据库.本文将总结这些特殊用法.

## 分布式条件下使用redis的注意点

### 命名空间

redis的设计可以说相当简陋,不像一般的关系数据库会分db,schema,表.能用的只有一个`db`(单机模式默认16个,集群则只有1个)和`key`,而`key`就是一个字符串,因此并不便于管理.
而redis往往却是用在一个分布式系统中,这就很有必要做好分库和命名规范.

习惯上我们通过用`::`来标识命名空间的方式来给键分组.命名空间按从大范围到小范围的,同级范围按范围名首字母排序的方式进行构造.这一习惯可以很好的避免因为key命名混乱造成的数据管理问题.

### 使用什么样方式部署redis服务

标准版redis有4种部署方式

1. 单点部署(standalone),就是在一台机器上部署一个redis实例.

    这是最简单的一种部署方式.有完善的持久化方案,但无法保证在极端情况下数据不丢失,也无法保证高可用,更无法支持横向扩展

2. 主从模式部署(master-slave),就是一个单点作为主节点,多个节点作为从节点,主从之间通过全量同步(刚建立关系时)和增量同步(建立好关系后)的方式同步数据.

    它一般用于单点部署无法满足性能要求时做读写分离,即master做写操作,slaver做读操作.相当于在数据持久化之外增加了热备和对读操作的容灾.
    从主从模式开始redis就无法保证数据的强一致性了,因为redis的同步方式是异步同步的,所以说只能保证最终一致性.

3. 哨兵模式部署(Sentinel),主从模式的升级款,通过哨兵节点监控集群判断master节点是否可用以及对slave的选举来实现高可用.

    其原理是通过哨兵集群监控主节点状态,如果多数哨兵同意主节点下线则将主节点下线,然后在从节点中选举一个作为主节点.
    它是主从模式的升级,通过这种方式确保了redis服务的高可用

4. 集群模式部署(cluster),去中心化的集群模式.

    通过多个master保存整个集群中的全部数据,而数据根据key进行`crc-16`校验算法进行散列,将key散列成对应16383个slot,而Redis cluster集群中每个master节点负责不同的slot范围.每个master节点下还可以配置多个slave节点,同时也可以在集群中再使用sentinel哨兵提升整个集群的高可用性.
    集群模式做到高可用的同时代价是没有了一些特性:

     1. key批量操作支持有限.如`MSET`,`MGET`目前只支持具有相同slot值的key执行批量操作.对于映射为不同slot值的key由于执行`MSET`,`MGET`等操作可能存在于多个节点上因此不被支持.
     2. key事务操作支持有限,理由和上面一样,只支持多key在同一节点上的事务操作,当多个key分布在不同的节点上时无法使用事务功能.
     3. key作为数据分区的最小粒度,因此不能将一个大的键值对象如hash,list等映射到不同的节点.
     4. 不支持多数据库空间.单机下的Redis可以支持16个数据库,集群模式下只能使用一个数据库空间即`db0`
     5. 复制结构只支持一层,从节点只能复制主节点,不支持嵌套树状复制结构.

这4种模式特点的可以总结为如下表格:

模式|数据高一致性|服务高可用|可扩展性|部署难度|功能完整性
---|---|---|---|---|---
单节点|强一致性|否|否|简单|全
主从|最终一致性|否|是|一般|全
哨兵|最终一致性|是|是|一般|全
集群|最终一致性|是|是|复杂|不全

并不是说我们应该用哪种方式部署,而是我们应该根据不同的实际情况和使用场景(主要是请求量和服务可用性要求)来选择不同的部署方式和不同的服务端配置.

像一般的场景下单节点就已经是非常够用好维护的了.而如果请求量过高或者读写请求量非常不平衡,又或者只是想有热备功能那么我们就可以用主从模式做读写分离.如果对高可用有较高的要求比如主要用它作为消息中间件这样的场景,那么哨兵模式就是一个可以考虑的模式.
而集群模式虽然强大但相对比较复杂而且使用上会有些限制.

对于自建机房的来说我建议采用如下原则:

1. 每个实例(redis节点)一台物理机器.
2. 部署redis节点的机器不要执行其他程序

以上面的原则部署的话再考虑好成本和需求你大致就可以知道应该怎么部署了.

对于托管在云服务上的(比如aws,阿里云)的来说,建议你直接购买他们提供的redis服务,算上维护成本其实也不会比买机器自己搭建贵太多.

## 尽量避免执行堵塞操作



## 全局去重

redis

## 定时器


## 全局计数器

redis可以使用$2^64$ 而pg序列最大只能到$2^31$虽然都已经是天文数字了但依然有巨大的差异.而一般数据库一旦做分表,那系统给的自增id,无论是pg的`series`,还是mysql的`AUTO_INCREMENT`都无法简单扩展,像我之前用pg就没有考虑到这点,因此后来设计按天分表后不得不去掉主键约束.

如果使用redis的自增就可以一定程度上解决这个问题.

+ `INCR <key>`自增,每次加1
+ `INCRBY <key> <amount>`自增,每次加amount

注意做全局计数器的机器最好做好主备集群.防止有机器蹦了后信息消失

### 扩展--在线用户查询

如果用户数量又超大那我们要查看某个用户在不在线就成了问题,如果刚好我们的用户id是整型,比如是用全局计数器生成用户id,那还有一个扩展应用就是可以快速查找用户是否在线,原理很简单,使用`setbit <key> <offset> <value>`

使用redis的用户id作为offset,如果用户登录了就为这个offset的value置1,下线了就为其置0,这样我们要知道一个用户是否在线只要用它的id作为offset使用命令`GETBIT <key> <offset>`查询即可,是1就在线是0就不在线,而如果要统计在线人数只需要使用`BITCOUNT <key>`就可以查出来.

## 分布式锁

有时候页面卡我们会习惯性的连续点击提交,这就会造成重复请求,尤其在还有负载均衡的情况下,这些请求还可能给发给不同的服务器.如何避免呢?我们可以用请求的`ip+url+request`做hash作为key,设置`setnx <key> <value>`

这个命令会在没有key时设置key的值为value且返回1,当已经有key时无论怎么用setnx设置这个key的value都会返回0通常我们会给它设置一个过期时间,比如3s

```
setnx <key> <value>
EXPIRE <key> <seconds>
```

这样就达到了一定时间内无法重复提交请求的效果

## 快速排序

Redis的有序集合(sorted set)可以快速进行排序,比如做搜索引擎,我们就可以将权重计算做成一个分布式任务,然后将url的权重按命令`ZADD <key> <weight> <url>`放入redis,需要取值时使用`ZRANGE <key> <from> <to> WITHSCORES`就可以取出范围内的url了

## 缓存

redis最常用的功能自然是缓存.这个功能相当于给分布式系统提供了一个公用内存,很多时候网站的用户访问会话信息就是存缓存的.这样可以避免过早的触及数据库的io瓶颈.

由于redis的key自带过期,这也是一种方便的缓存管理工具,每个缓存都应该设置好过期避免冷数据停留在其中.

## 扩展--限流

限流其实也算一种分布式锁了,我们可以固定一些接口的访问流量防止被恶意攻击,我们可以使用redis插件[redis-cell](https://github.com/brandur/redis-cell),安装好插件的redis镜像我已经发布在[hsz1273327/redis-cell](https://cloud.docker.com/u/hsz1273327/repository/docker/hsz1273327/redis-cell),使用上可以去镜像站查看用法

## 扩展--布隆过滤器

