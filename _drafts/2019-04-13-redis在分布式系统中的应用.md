---
layout: post
title: "redis在分布式系统中的应用"
date: 2019-04-13
author: "Hsz"
category: experiment
tags:
    - Architecture
    - Middleware
header-img: "img/home-bg-o.jpg"
update: 2020-12-31
---
# redis在分布式系统中的应用

redis作为一个key-value内存数据库,因为其附带有性能优越的多种数据结构,在应用上带来了很多附加功能呢.在分布式系统中redis常作为一些特殊的中间件存在而非单纯的内存数据库.本文将总结这些特殊用法.

## 分布式条件下使用redis的注意点

### 命名空间

redis的设计可以说相当简陋,不像一般的关系数据库会分db,schema,表.能用的只有一个`db`(单机模式默认16个,集群则只有1个)和`key`,而`key`就是一个字符串,因此并不便于管理.
而redis往往却是用在一个分布式系统中,这就很有必要做好分库和命名规范.

习惯上我们通过用`::`来标识命名空间的方式来给键分组.命名空间按从大范围到小范围的,同级范围按范围名首字母排序的方式进行构造.这一习惯可以很好的避免因为key命名混乱造成的数据管理问题.

### 使用什么样方式部署redis服务

标准版redis有4种部署方式

1. 单点部署(standalone),就是在一台机器上部署一个redis实例.

    ![单点部署][1]

    这是最简单的一种部署方式.有完善的持久化方案,但无法保证在极端情况下数据不丢失,也无法保证高可用,更无法支持横向扩展

2. 主从模式部署(master-slave),就是一个单点作为主节点,多个节点作为从节点,主从之间通过全量同步(刚建立关系时)和增量同步(建立好关系后)的方式同步数据.

    ![主从模式部署][2]

    它一般用于单点部署无法满足性能要求时做读写分离,即master做写操作,slaver做读操作.相当于在数据持久化之外增加了热备和对读操作的容灾.
    从主从模式开始redis就无法保证数据的强一致性了,因为redis的同步方式是异步同步的,所以说只能保证最终一致性.

3. 哨兵模式部署(Sentinel),主从模式的升级款,通过哨兵节点监控集群判断master节点是否可用以及对slave的选举来实现高可用.

    ![哨兵模式部署][3]

    其原理是通过哨兵集群监控主节点状态,如果多数哨兵同意主节点下线则将主节点下线,然后在从节点中选举一个作为主节点.
    它是主从模式的升级,通过这种方式确保了redis服务的高可用

4. 集群模式部署(cluster),去中心化的集群模式.

    ![集群模式部署][4]

    通过多个master保存整个集群中的全部数据,而数据根据key进行`crc-16`校验算法进行散列,将key散列成对应16383个slot,而Redis cluster集群中每个master节点负责不同的slot范围.每个master节点下还可以配置多个slave节点,同时也可以在集群中再使用sentinel哨兵提升整个集群的高可用性.
    集群模式做到高可用的同时代价是没有了一些特性:

     1. key批量操作支持有限.如`MSET`,`MGET`目前只支持具有相同slot值的key执行批量操作.对于映射为不同slot值的key由于执行`MSET`,`MGET`等操作可能存在于多个节点上因此不被支持.
     2. key事务操作支持有限,理由和上面一样,只支持多key在同一节点上的事务操作,当多个key分布在不同的节点上时无法使用事务功能.
     3. key作为数据分区的最小粒度,因此不能将一个大的键值对象如hash,list等映射到不同的节点.
     4. 不支持多数据库空间.单机下的Redis可以支持16个数据库,集群模式下只能使用一个数据库空间即`db0`
     5. 复制结构只支持一层,从节点只能复制主节点,不支持嵌套树状复制结构.

这4种模式特点的可以总结为如下表格:

模式|数据高一致性|服务高可用|可扩展性|部署难度|功能完整性
---|---|---|---|---|---
单节点|强一致性|否|否|简单|全
主从|最终一致性|否|是|一般|全
哨兵|最终一致性|是|是|一般|全
集群|最终一致性|是|是|复杂|不全

并不是说我们应该用哪种方式部署,而是我们应该根据不同的实际情况和使用场景(主要是请求量和服务可用性要求)来选择不同的部署方式和不同的服务端配置.

像一般的场景下单节点就已经是非常够用好维护的了.而如果请求量过高或者读写请求量非常不平衡,又或者只是想有热备功能那么我们就可以用主从模式做读写分离.如果对高可用有较高的要求比如主要用它作为消息中间件这样的场景,那么哨兵模式就是一个可以考虑的模式.
而集群模式虽然强大但相对比较复杂而且使用上会有些限制.

对于自建机房的来说我建议采用如下原则:

1. 每个实例(redis节点)一台物理机器.
2. 部署redis节点的机器不要执行其他程序

以上面的原则部署的话再考虑好成本和需求你大致就可以知道应该怎么部署了.

对于托管在云服务上的(比如aws,阿里云)的来说,建议你直接购买他们提供的redis服务,算上维护成本其实也不会比买机器自己搭建贵太多.

## 尽量避免执行堵塞操作

由于redis使用异步架构,所以一旦有堵塞操作就会造成整体的堵塞,而且集群模式也并不支持堵塞操作.

![redis的架构][5]

redis中的堵塞操作包括:

+ `keys全量查询`:所有要查询全量的操作都是会堵塞的
+ `bigkey删除`:删除操作的本质是要释放键值对占用的内存空间,一下子释放了大量内存会造成Redis主线程的阻塞.
+ `清空数据库`:频繁删除键值对是潜在风险,清空数据库必然也是一个潜在风险.
+ `AOF日志同步写`:一个同步写磁盘的操作的耗时大约1~2ms,如果有大量写操作需要记录到AOF日志并同步写回就会阻塞主线程.
+ `从库加载RDB文件`:RDB文件越大阻塞越久.

多数时候我们要注意的就是前2种操作:

1. 避免用`keys`查找键,使用`SCAN cursor [MATCH pattern] [COUNT count]`迭代的查找键
2. 避免批量的`del`键,比较优雅的方式是为每个键设置过期

## 充分利用键的过期功能

redis的一大优势在于可以为key设置过期,注意redis的过期并不代表键已经被删除了,而是会在如下情况下删除:

1. 惰性删除,也就是在下次请求时如果发现键存在且已经过期则会被删除
2. 定时删除,redis的子线程会定时删除已经被标注为过期的键,默认10s,这个可以在配置种设置`hz`来改变间隔

键可以过期的优势有如下几个:

1. 一定程度上避免内存无限扩张,如果过期设置合理完全可以不用对key做额外的删除设置,同时保证保存的都是自己需要的键
2. 过期本身也是信息,可以被利用

下面是几个利用过期的场景

### 简易限流器

我们可以通过设置一个很短过期时间的键来控制用户的访问频率,从而避免恶意用户频繁访问挤爆服务器的情况.基本思路是:

1. 为每个用户设置一个key,这个key用string类型,并使用计数器功能
2. 为这个可以设置一个较短的过期时间,比如10s,
3. 设置一个阈值,计数器到达这个阈值则不再为用户提供服务,一般会根据最大过期时间和系统的承载能力来设置,比如10s就设5次,1min就设置50次这样.
4. 用户每次请求就向自己的key中加1,同时根据获得的结果判断是否超过阈值来判断是否继续执行用户的这次请求

这样相当于从第一次访问起每隔过期时间内最多就执行设置阈值数量的请求.当然这个方案只是一个很简陋的方案,下面会有更好的解决方案.

### 记录用户行为上下文

这也是一个很常见的用法,一般我们要分析一个用户就需要记录它的行为.但行为往往是序列,是有上下文的,比如一个用户看到了页面上10个推荐项,然后他点击了其中一个,那这次的点击自然是和他看到的页面上的10个推荐项有关的.但往往我们收集的数据都是孤立的不带上下文信息的因此最简单的办法是通过一个id将用户的上下文行为串联起来.比较常见的上下文可以归结为如下:

1. 一次会话行为(从登录到退出),比如我们打开网易云听歌开始,到关闭它结束

2. 一次查找行为(从进入页面到找到需要的物品),

## 全局计数器

redis的`string(INCR)`和`hash(HINCRBY)`的filed都支持作为计数器,可以生成最大`$2^64$`的连续整数.这个功能通常用于给分布式系统做全局唯一键(当然更好的办法是使用uuid或者snowflake算法)

下面是几个常见的使用场景

### 用户id生成器

虽然mysql,pg都有自增类型,但真到了一定数据规模,分库分包就势在必行,这种时候一般mysql/pg的自增就失效了,因此更好的办法是将用户的id生成放在外部,这时候就可以使用redis的全局计数器功能了.

用作用户id的优势在于:

1. 是整型数据,节省存储空间,用户id通常会关联很多表,如果用字符串型必然会占用不少空间
2. 天然可以排序,用户id的早晚本身就是信息,可以在一些情况下用于区分新老用户
3. 可以结合下面的bitmap用于做在线用户查询
4. 足够大.

## 全局去重

redis提供了好几种去重的方式,他们各有特点

数据结构|特点
---|---
`Set`|最传统的集合数据类型,功能全面,但空间占用大
`sorted set`|带权重的集合,除了set的功能外它会带一个用于排序的权重
`bitmap`|位图,本质上就是个string,它只能为int型的数据做去重,它的空间占用只和加入的最大值有关,最大占用空间为512M,通常可以比使用set更加省空间.但代价是要更多的使用cpu
`Hyperloglog`|这个结构只能用于去重计数,而且无法保证精确,通常只在粗略估计的时候使用,但它比bitmap更加省空间.

下面是几个使用全局去重的场景

### 在线用户查询(bitmap)

如果用户数量又超大那我们要查看某个用户在不在线就成了问题,如果刚好我们的用户id是整型,比如是用全局计数器生成用户id,那还有一个扩展应用就是可以快速查找用户是否在线,原理很简单,使用`setbit <key> <offset> <value>`

方法也很简单:

1. 用户登录就为用户设置id为offset的位置为1
2. 用户下线就为用户设置id为offset的位置为0
3. 查看用户是否在线就查看用户id位置的offset是否为1,为1就在线.为0就不在线

这个里面关键问题在于如何确定用户是否上线下线.一般可以用如下方法:

1. 用户产生请求就视为上线
2. 用户主动调用下线接口视为下线
3. 用户

### 扩展--在线用户查询

如果用户数量又超大那我们要查看某个用户在不在线就成了问题,如果刚好我们的用户id是整型,比如是用全局计数器生成用户id,那还有一个扩展应用就是可以快速查找用户是否在线,原理很简单,使用`setbit <key> <offset> <value>`

使用redis的用户id作为offset,如果用户登录了就为这个offset的value置1,下线了就为其置0,这样我们要知道一个用户是否在线只要用它的id作为offset使用命令`GETBIT <key> <offset>`查询即可,是1就在线是0就不在线,而如果要统计在线人数只需要使用`BITCOUNT <key>`就可以查出来.

## 分布式锁

有时候页面卡我们会习惯性的连续点击提交,这就会造成重复请求,尤其在还有负载均衡的情况下,这些请求还可能给发给不同的服务器.如何避免呢?我们可以用请求的`ip+url+request`做hash作为key,设置`setnx <key> <value>`

这个命令会在没有key时设置key的值为value且返回1,当已经有key时无论怎么用setnx设置这个key的value都会返回0通常我们会给它设置一个过期时间,比如3s

```
setnx <key> <value>
EXPIRE <key> <seconds>
```

这样就达到了一定时间内无法重复提交请求的效果

## 快速排序

Redis的有序集合(sorted set)可以快速进行排序,比如做搜索引擎,我们就可以将权重计算做成一个分布式任务,然后将url的权重按命令`ZADD <key> <weight> <url>`放入redis,需要取值时使用`ZRANGE <key> <from> <to> WITHSCORES`就可以取出范围内的url了

## 缓存

redis最常用的功能自然是缓存.这个功能相当于给分布式系统提供了一个公用内存,很多时候网站的用户访问会话信息就是存缓存的.这样可以避免过早的触及数据库的io瓶颈.

由于redis的key自带过期,这也是一种方便的缓存管理工具,每个缓存都应该设置好过期避免冷数据停留在其中.

## 扩展--限流

限流其实也算一种分布式锁了,我们可以固定一些接口的访问流量防止被恶意攻击,我们可以使用redis插件[redis-cell](https://github.com/brandur/redis-cell),安装好插件的redis镜像我已经发布在[hsz1273327/redis-cell](https://cloud.docker.com/u/hsz1273327/repository/docker/hsz1273327/redis-cell),使用上可以去镜像站查看用法

## 扩展--布隆过滤器

[1]: {{site.url}}/img/in-post/redis/standalone.png
[2]: {{site.url}}/img/in-post/redis/master-slaver.png
[3]: {{site.url}}/img/in-post/redis/sentinel.png
[4]: {{site.url}}/img/in-post/redis/cluster.png
[5]: {{site.url}}/img/in-post/redis/redis架构.jpg