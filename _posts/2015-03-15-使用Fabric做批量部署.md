---
layout: post
title: "使用Fabric做批量部署"
date: 2015-03-15
author: "Hsz"
category: introduce
tags:
    - DevOps
header-img: "img/post-bg-2015.jpg"
update: 2019-03-15
---
# 使用Fabric做批量部署

fabric和pip,virtualenv并称python开发的三神器.它是远程配置工具,和另外俩还不一样,
fabric不单可以配置python还可以配置其他任何项目,远程监控,部署,运行项目,唯一不好的是它重度依赖ssh.

## 安装

fabric的安装依赖于ssh和python,可以使用pip安装.

```shell
pip install fabric
```

## 简单的helloworld

我们来通过一个简单的helloworld来看看fabric是怎么工作的.

### step1--写`fabfile.py`

fabric通过读取fabfile定义操作,他的定义方式和一般的python函数差不多

```fabfile
from fabric.api import local

def helloworld():
    local("echo helloworld")
def hello_name(name):
    local("echo hello {name}".format(name=name))
```

这个fabfile定义了两个本地操作动作(local方法是在本地运行),一个不带参数的helloworld,一个带参数的hello_name

### step2--使用`fab` 命令运行操作

```shell
fab helloworld
```

结果:

```shell
[localhost] local: echo helloworld
helloworld

Done.
```

```shell
fab hello_name:name=hsz
```

结果:

```shell
[localhost] local: echo hello hsz
hello hsz

Done.
```

知道怎么用了下一部分我们将讲解一些fab命令的细节和参数.

## fab命令

fab命令是fabric自带的一个命令行工具,可以用来确定连接哪台服务器,stdout的输出等级等一系列参数

```shell
fab [options] -- [shell command]
```

### 基本用法

```shell
fab task1 task2
```

fabric可以连续操作,并不只限于单步操作

### 参数

参数|说明(常用的翻译)
---|---
-f FABFILE, --fabfile=FABFILE | 指定fabfile文件
-h, --help|帮助信息
--hide=LEVELS|输出的隐藏等级
-H HOSTS, --hosts=HOSTS|指定要部署的服务器
-i KEY_FILENAME|当ssh登录认证是文件时用力指定认证文件
-I, --initial-password-prompt|指定当sudo等操作需要password时自动输入的密码
--linewise| output输出的缓冲为一行一行而不是一个字节一个字节
-l, --list|查看有哪些已定义的动作
--set KEY=VALUE,...|设置fabric的环境变量
-u USER, --user=USER|设置ssh访问时使用的用户名
-V, --version|查看fabric的版本信息
-w, --warn-only | fabric报错也继续执行
-z, --pool-size| 并行执行是的进程池大小
-p PASSWORD, --password=PASSWORD | 设置ssh登录密码
-P, --parallel|并行处理动作而非顺序处理
--timeout=N, -t N|ssh连接如果超时则断开,这边是超时时间的设定
--command-timeout=N, -T N| 命令超时设定
--no-pty|Sets env.always_use_pty to False, causing all run/sudo calls to behave as if one had specified pty=False.
-r, --reject-unknown-hosts|Sets env.reject_unknown_hosts to True, causing Fabric to abort when connecting to hosts not found in the user’s SSH known_hosts file.
-R ROLES, --roles=ROLES|Sets env.roles to the given comma-separated list of role names.
-s SHELL, --shell=SHELL|Sets env.shell to the given string, overriding the default shell wrapper used to execute remote commands.
--shortlist|Similar to --list, but without any embellishment, just task names separated by newlines with no indentation or docstrings.
--ssh-config-path|Sets env.ssh_config_path.
--skip-bad-hosts|Sets env.skip_bad_hosts, causing Fabric to skip unavailable hosts.
--skip-unknown-tasks|Sets env.skip_unknown_tasks, causing Fabric to skip unknown tasks.
--keepalive=KEEPALIVE|Sets env.keepalive to the given (integer) value, specifying an SSH keepalive interval.
-F LIST_FORMAT, --list-format=LIST_FORMAT|Allows control over the output format of --list. short is equivalent to --shortlist, normal is the same as simply omitting this option entirely (i.e. the default), and nested prints out a nested namespace tree.
-a, --no_agent| Sets env.no_agent to True, forcing our SSH layer not to talk to the SSH agent when trying to unlock private key files.
-A, --forward-agent|Sets env.forward_agent to True, enabling agent forwarding.
--abort-on-prompts | Sets env.abort_on_prompts to True, forcing Fabric to abort whenever it would prompt for input.
-c RCFILE, --config=RCFILE |Sets env.rcfile to the given file path, which Fabric will try to load on startup and use to update environment variables.
-d COMMAND, --display=COMMAND|Prints the entire docstring for the given task, if there is one. Does not currently print out the task’s function signature, so descriptive docstrings are a good idea. (They’re always a good idea, of course – just moreso here.)
--connection-attempts=M, -n M |Set number of times to attempt connections. Sets env.connection_attempts.
-D, --disable-known-hosts|Sets env.disable_known_hosts to True, preventing Fabric from loading the user’s SSH known_hosts file.
-g HOST, --gateway=HOST|Sets env.gateway to HOST host string.
--gss-auth|Toggles use of GSS-API authentication.
--gss-deleg|Toggles whether GSS-API client credentials are delegated.
--gss-kex|Toggles whether GSS-API key exchange is used.
-x HOSTS, --exclude-hosts=HOSTS|Sets env.exclude_hosts to the given comma-delimited list of host strings to then keep out of the final host list.
-k|Sets env.no_keys to True, forcing the SSH layer to not look for SSH private key files in one’s home directory.


## fabfile定义动作

fabfile是fabric的核心,通过在`fabfile.py`中定义动作来实现功能.

这部分会分为:

+ 本地与远程操作基本功能
+ 上下文设定
+ 询问与报错
+ stdout输出等级

### 本地与远程操作基本功能

fabric基本操作可以分为本地操作和远程操作,远程操作同样可以通过ssh连接localhost来操作本机,
而本地操作就是单纯的本地操作而已.

#### 本地操作

操作|说明
---|---
local| 运行本地命令

#### 远程操作

操作|说明
---|---
run|远程运行
sudo|sudo权限运行
put|将文件传送到远端
get|从远程服务器上下载文件
open_shell|远端开启一个交互shell
prompt|提示输入

### 上下文设定

我们操作shell也往往需要上下文,比如要在特定的目录下运行特定的文件等.python中专门为上下文准备的语句就是`with`语句.

常见的上下文操作有:


+ `with cd(path)/lcd(path)`定位
+ `with hide('running', 'stdout', 'stderr')` 设定输出
+ `with setting(env=val)` 情景设定
+ `with prefix(pre)` 设定前一步动作
+ `with shell_env()`设置环境变量

### 询问与报错

有时候我们的命令并不正确,会报错,怎么才能知道?判断结果中的

#### 错误处理

我们的run()或者local()方法会返回一个值,它的字面量就是输出的内容文本,
而它有一个属性`.failed`如果是False则说明没出错,而如果是True则说明出错了.

如何处理错误,看个例子:

```python
def test():
    with settings(warn_only=True):
        result = local('./manage.py test my_app', capture=True)
    if result.failed and not confirm("Tests failed. Continue anyway?"):
        abort("Aborting at user request.")

```

+ confirm类似python里的raw_input(),他会让你输入一个值,这个例子中它是默认状态,要求输入yes/no,返回一个布尔值.

+ abort()类似flask中的abort,就是报错

#### 询问

询问可以设置具体的形式,有以下几种

```python
environment = prompt('Please specify target environment: ')##


prompt('Specify favorite dish: ', 'dish', default='spam & eggs')#有默认值,并且存入env.dish

prompt('Please specify process nice level: ', key='nice', validate=int)#带有类型验证的输入

release = prompt('Please supply a release name',
        validate=r'^\w+-\d+(\.\d+)?$')# 使用re验证

# Prompt regardless of the global abort-on-prompts setting:
with settings(abort_on_prompts=False):
    prompt('I seriously need an answer on this!')

```

### 输出等级

fabric允许的输出等级有:

等级|说明
---|---
status:| Status messages, i.e. noting when Fabric is done running, if the user used a keyboard interrupt, or when servers are disconnected from. These messages are almost always relevant and rarely verbose.
aborts: |Abort messages. Like status messages, these should really only be turned off when using Fabric as a library, and possibly not even then. Note that even if this output group is turned off, aborts will still occur – there just won’t be any output about why Fabric aborted!
warnings:| Warning messages. These are often turned off when one expects a given operation to fail, such as when using grep to test existence of text in a file. If paired with setting env.warn_only to True, this can result in fully silent warnings when remote programs fail. As with aborts, this setting does not control actual warning behavior, only whether warning messages are printed or hidden.
running: |Printouts of commands being executed or files transferred, e.g. [myserver] run: ls /var/www. Also controls printing of tasks being run, e.g. [myserver] Executing task 'foo'.
stdout: |Local, or remote, stdout, i.e. non-error output from commands.
stderr: |Local, or remote, stderr, i.e. error-related output from commands.
user: User-generated output, i.e. local output printed by fabfile code via use of the fastprint or puts functions.


#### 有颜色的输出

`fabric.colors`中的颜色方法可以为字符串修改为对应颜色,如:

```python
from fabric.colors import green

print(green("This text is green!"))
```


