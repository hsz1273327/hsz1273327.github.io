---
layout: post
title: "使用Fabric做远程批量部署"
date: 2020-10-22
author: "Hsz"
category: introduce
tags:
    - DevOps
    - python
    - SSH
    - Remote Access
header-img: "img/post-bg-2015.jpg"
update: 2020-10-22
---
# 使用Fabric做批量远程部署

[fabric](https://github.com/fabric/fabric)是上古python开发的三神器之一.它是远程配置工具,重度依赖ssh.
目前fabric已经到了大版本2,其接口已经和之前有很大不同,本文基于fabric 2

fabric有两种使用方式:

1. 命令行调用方式.

    我们可以先定义好远程任务要执行的操作,然后通过命令行传入要执行的远程主机,要调用的任务等参数.
    这种方式的定义过程像是写makefile.也是fabric v1版本的唯一使用方式.好处是使用和开发解耦,使用者并不需要会python也不用看得懂代码.调用就好了.

2. python包调用方式.

    这是v2版本增加的方式,现在fabric可以使用接口直接调用执行.这种方式的好处是灵活,坏处就是要用的人能看得懂才行.

## 安装

fabric的安装依赖于ssh和python,可以使用pip安装.

```shell
pip install fabric
```

注意fabric依赖的[invoke](https://github.com/pyinvoke/invoke)有一个[bug](https://github.com/pyinvoke/invoke/issues/357)会导致使用python的typehints会报错,可以通过手动修改其中的源文件第153行(argspec方法中)的代码

`spec = inspect.getargspec(func)`改为`spec = inspect.getfullargspec(func)`解决

## helloworld

我们还是从helloworld开始

### 命令行调用方式

1. 写`fabfile.py`

    fabric通过读取fabfile定义操作,他的定义方式和一般的python函数差不多

    ```python
    from fabric import task, Connection


    @task
    def helloworld(c: Connection) -> None:
        result = c.run('echo helloworld', hide=True)
        msg = f"Ran {result.command!r} on {result.connection.host}, got stdout:\n{result.stdout}"
        print(msg)


    @task()
    def hello_name(c: Connection, name: str) -> None:
        result = c.run(f'echo hello {name}', hide=True)
        msg = f"Ran {result.command!r} on {result.connection.host}, got stdout:\n{result.stdout}"
        print(msg)

    ```

    这个fabfile定义了两个任务,一个不带参数的helloworld,一个带参数的hello_name

2. 使用`fab` 命令运行操作

    ```shell
    fab -H remot1 helloworld
    ```

    结果:

    ```shell
    Ran 'echo helloworld' on 47.110.255.149, got stdout:
    helloworld
    ```

    执行带参数的任务时则需要指定参数的值

    ```shell
    fab -H remot1 hello_name --name=hsz
    ```

    结果:

    ```shell
    Ran 'echo hello hsz' on 47.110.255.149, got stdout:
    hello hsz
    ```

### python包调用方式

这种方式我们就只需要写个python脚本,然后执行它就行

+ `fabcall.py`

    ```python
    from fabric import Connection

    if __name__ == "__main__":
        conn = Connection('remot1')
        result = conn.run('echo helloworld', hide=True)
        msg = f"Ran {result.command!r} on {result.connection.host}, got stdout:\n{result.stdout}"
        print(msg)
        conn.close()
    ```

然后直接执行`python fabcall.py`即可

## fabric的核心用法

上面的例子中我们可以看出无论是哪种使用方式,fabric的使用大致都由如下几块构成:

1. 定义和构造连接
2. 在连接上执行命令
3. 获得并处理命令的结果.

这就是fabric的核心用法,下面开始详细介绍

### 定义和构造连接

fabric的`Connection`类用于实例化一个ssh连接.其签名为

```python
Connection(
    host, user=None, port=None, 
    config=None, gateway=None, 
    forward_agent=None, connect_timeout=None, 
    connect_kwargs=None, inline_ssh_env=None)
```

一个连接的生命周期是`创建->建立连接->执行任务->关闭连接`.连接是可以使用上下文管理器管理的.

因此上面包调用方式的helloworld我们应该写成

```python
from fabric import Connection

if __name__ == "__main__":
    with Connection('xndm_test') as conn:
        result = conn.run('echo helloworld', hide=True)
        msg = f"Ran {result.command!r} on {result.connection.host}, got stdout:\n{result.stdout}"
        print(msg)
```

连接的指定主要依靠参数`host`参数,它可以是3种情况

1. 远程主机的`hostname`,这种情况下需要视情况填写`user`,`port`这样的参数了
2. 远程主机的配置简写形式`user@host:port`,这种情况下就没有必要填写`user`,`port`这样的参数了
3. 远程主机在ssh配置文件种定义的连接别名,这种情况下也没有必要填写`user`,`port`这样的参数了

对于有验证的情况我们可以这样设置

| 验证形式             | 字段                                                      | 命令行参数设置            | 配置示例                                   |
| -------------------- | --------------------------------------------------------- | ------------------------- | ------------------------------------------ |
| 指定私钥             |                                                           | ---                       | `connect_kwargs={"key_filename":"<path>"}` |
| 指定私钥且私钥有密码 | `connect_kwargs.key_filename`,`connect_kwargs.passphrase` | `--prompt-for-passphrase` |                                            |

+ 指定私钥
    + 参数字段`connect_kwargs.key_filename`
    + 参数配置示例

    ```python
    connect_kwargs={
        "key_filename":"<path>"
    }
    ```

+ 指定私钥且私钥有密码
    + 参数字段`connect_kwargs.key_filename`,`connect_kwargs.passphrase`
    + 参数配置示例

    ```python
    connect_kwargs={
        "key_filename":"<path>",
        "passphrase":"132"
    }
    ```

    + 命令行参数设置`--prompt-for-passphrase=132`

+ 密码登录
    + 参数字段`connect_kwargs.password`
    + 参数配置示例

    ```python
    connect_kwargs={
        "password":"12421"
    }
    ```

    + 命令行参数设置`--prompt-for-login-password=12421`

私钥的密码或者登录密码最好不要明文写在代码里,不安全.在接口调用方式下可以通过环境变量传入或者用标准库`getpass`来从命令行输入;在命令行调用方式下可以使用命令行参数在执行前输入.

使用`getpass`可以参考如下示例:

```python
import getpass
access_pass = getpass.getpass("登录密码是?")
connect_kwargs={
    "password":access_pass
}
```

#### 连接组

当我们要一组连接都执行同样的任务时有两种方式:

+ 遍历连接的配置构造多个连接,然后每个连接执行一遍任务
+ 使用fabric的`SerialGroup`或者`ThreadingGroup`类(`Group`类的子类).

连接组在命令行调用方式下一般用不到,但在包调用方式中还算好用.
  
连接组的签名为:

```python
Group(*hosts, **kwargs)
```

其中`kwargs`和上面连接中的一致.

可以通过`run`,`get`接口在每个连接上执行命令行操作,也可以使用`close()`接口关闭其中的所有连接.类似连接它也是一个上下文管理器,可以使用with语法.

同时它也可以遍历,其中的元素为各个配置对应的连接.

我们修改上面包调用方式的helloworld,改成可以同时在两个远程服务器上执行的形式.

```python
from fabric import ThreadingGroup as Group

if __name__ == "__main__":
    with Group('remote1', 'remote2') as group:
        results = group.run('echo helloworld', hide=True)
        for conn, result in results.items():
            msg = f"conn {conn.host} Ran {result.command!r} on {result.connection.host}, got stdout:\n{result.stdout}"
            print(msg)

```

结果:

```bash
conn 47.96.235.24 Ran 'echo helloworld' on 47.96.235.24, got stdout:
helloworld

conn 47.110.255.149 Ran 'echo helloworld' on 47.110.255.149, got stdout:
helloworld
```

### 在连接上执行命令

在连接上执行命令有如下几个接口:

| 操作     | 说明                              |
| -------- | --------------------------------- |
| `run`    | 远程运行                          |
| `sudo`   | sudo权限运行                      |
| `cwd`    | 获取当前的路径信息                |
| `cd`     | 执行路径切换                      |
| `prefix` | 执行`run/sudo`前的操作,相当于`&&` |
| `put`    | 将文件传送到远端                  |
| `get`    | 从远程服务器上下载文件            |

#### `run`执行命令行任务

`run`接口是在连接上执行命令的核心.它的接口是

```python
run(command:str, **kwargs:Any)->Result
```

主要的参数:

+ `command`是要执行的命令字符串
+ `warn`当命令执行异常退出时默认是抛出`UnexpectedExit`异常,如果设置`warn`则不会抛出错误而是改为抛出警告
+ `hide`可选的值为
    + `"out"/"stdout"` 打印远端的stdout输出的结果
    + `"err"/"stderr"` 打印远端的stderr输出的结果
    + `"both"/True`stdout或者stderr输出的结果都打印
    + `None`所有都打印(默认)
    + `False`都不打印
+ `disown` 相当于`nohup command &`
+ `env`其值为一个字典,用于定义命令执行时的环境变量
+ `encoding`stdout和stderr的文本编码
+ `watchers`定义监控,一般用于自动填写stdin.

> 处理需要在命令行中输入值的情况

比如一些安装脚本会要你确认是否同意一些内容条款,你必须输入`yes/no`这类的字符串来继续run的执行,这种时候可以定义一个`invoke.watchers.Responder`通过正则匹配的方式来自动响应

```python
responder = Responder(
    pattern=r"Are you ready? \[Y/n\] ",
    response="y\n",
)
c.run("excitable-program", watchers=[responder])
```

#### `sudo`使用root权限执行命令



#### 


### 获得并处理命令的结果



## fabric的任务和命令行工具`fab`

fab命令是fabric自带的一个命令行工具,可以用来确定连接哪台服务器,stdout的输出等级等一系列参数

```shell
fab [options] -- [shell command]
```

### 基本用法

```shell
fab task1 task2
```

fabric可以连续操作,并不只限于单步操作

### 常用参数

| 参数                               | 说明                                             |
| ---------------------------------- | ------------------------------------------------ |
| `-f FABFILE, --fabfile=FABFILE`    | 指定fabfile文件                                  |
| `-h, --help`                       | 帮助信息                                         |
| `--hide=LEVELS`                    | 输出的隐藏等级                                   |
| `-H HOSTS, --hosts=HOSTS`          | 指定要部署的服务器                               |
| `-i KEY_FILENAME`                  | 当ssh登录认证是文件时用于指定认证用的私钥        |
| `-I, --initial-password-prompt`    | 指定当`sudo`等操作需要password时自动输入的密码   |
| `--linewise`                       | output输出的缓冲为一行一行而不是一个字节一个字节 |
| `-l, --list`                       | 查看有哪些已定义的动作                           |
| `--set KEY=VALUE,...`              | 设置fabric的环境变量                             |
| `-u USER, --user=USER`             | 设置ssh访问时使用的用户名                        |
| `-V, --version`                    | 查看fabric的版本信息                             |
| `-w, --warn-only`                  | fabric报错也继续执行                             |
| `-z, --pool-size`                  | 并行执行是的进程池大小                           |
| `-p PASSWORD, --password=PASSWORD` | 设置ssh登录密码                                  |
| `-P, --parallel`                   | 并行处理动作而非顺序处理                         |
| `--timeout=N, -t N`                | ssh连接如果超时则断开,这边是超时时间的设定       |
| `--command-timeout=N, -T N`        | 命令超时设定                                     |
| `--ssh-config-path`                | 指定使用的ssh配置文件位置                        |

## fabfile定义动作

fabfile是fabric的核心,通过在`fabfile.py`中定义动作来实现功能.

这部分会分为:

+ 本地与远程操作基本功能
+ 上下文设定
+ 询问与报错
+ stdout输出等级

### 本地与远程操作基本功能

fabric基本操作可以分为本地操作和远程操作,远程操作同样可以通过ssh连接localhost来操作本机,
而本地操作就是单纯的本地操作而已.

#### 本地操作

| 操作  | 说明         |
| ----- | ------------ |
| local | 运行本地命令 |

#### 远程操作

| 操作       | 说明                   |
| ---------- | ---------------------- |
| run        | 远程运行               |
| sudo       | sudo权限运行           |
| put        | 将文件传送到远端       |
| get        | 从远程服务器上下载文件 |
| open_shell | 远端开启一个交互shell  |
| prompt     | 提示输入               |

### 上下文设定

我们操作shell也往往需要上下文,比如要在特定的目录下运行特定的文件等.python中专门为上下文准备的语句就是`with`语句.

常见的上下文操作有:


+ `with cd(path)/lcd(path)`定位
+ `with hide('running', 'stdout', 'stderr')` 设定输出
+ `with setting(env=val)` 情景设定
+ `with prefix(pre)` 设定前一步动作
+ `with shell_env()`设置环境变量

### 询问与报错

有时候我们的命令并不正确,会报错,怎么才能知道?判断结果中的

#### 错误处理

我们的run()或者local()方法会返回一个值,它的字面量就是输出的内容文本,
而它有一个属性`.failed`如果是False则说明没出错,而如果是True则说明出错了.

如何处理错误,看个例子:

```python
def test():
    with settings(warn_only=True):
        result = local('./manage.py test my_app', capture=True)
    if result.failed and not confirm("Tests failed. Continue anyway?"):
        abort("Aborting at user request.")

```

+ confirm类似python里的raw_input(),他会让你输入一个值,这个例子中它是默认状态,要求输入yes/no,返回一个布尔值.

+ abort()类似flask中的abort,就是报错

#### 询问

询问可以设置具体的形式,有以下几种

```python
environment = prompt('Please specify target environment: ')##


prompt('Specify favorite dish: ', 'dish', default='spam & eggs')#有默认值,并且存入env.dish

prompt('Please specify process nice level: ', key='nice', validate=int)#带有类型验证的输入

release = prompt('Please supply a release name',
        validate=r'^\w+-\d+(\.\d+)?$')# 使用re验证

# Prompt regardless of the global abort-on-prompts setting:
with settings(abort_on_prompts=False):
    prompt('I seriously need an answer on this!')

```

### 输出等级

fabric允许的输出等级有:

| 等级      | 说明                                                                                                                                                                                                                                                                                                                                                                                                |
| --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| status:   | Status messages, i.e. noting when Fabric is done running, if the user used a keyboard interrupt, or when servers are disconnected from. These messages are almost always relevant and rarely verbose.                                                                                                                                                                                               |
| aborts:   | Abort messages. Like status messages, these should really only be turned off when using Fabric as a library, and possibly not even then. Note that even if this output group is turned off, aborts will still occur – there just won’t be any output about why Fabric aborted!                                                                                                                      |
| warnings: | Warning messages. These are often turned off when one expects a given operation to fail, such as when using grep to test existence of text in a file. If paired with setting env.warn_only to True, this can result in fully silent warnings when remote programs fail. As with aborts, this setting does not control actual warning behavior, only whether warning messages are printed or hidden. |
| running:  | Printouts of commands being executed or files transferred, e.g. [myserver] run: ls /var/www. Also controls printing of tasks being run, e.g. [myserver] Executing task 'foo'.                                                                                                                                                                                                                       |
| stdout:   | Local, or remote, stdout, i.e. non-error output from commands.                                                                                                                                                                                                                                                                                                                                      |
| stderr:   | Local, or remote, stderr, i.e. error-related output from commands.                                                                                                                                                                                                                                                                                                                                  |
user: User-generated output, i.e. local output printed by fabfile code via use of the fastprint or puts functions.


#### 有颜色的输出

`fabric.colors`中的颜色方法可以为字符串修改为对应颜色,如:

```python
from fabric.colors import green

print(green("This text is green!"))
```


